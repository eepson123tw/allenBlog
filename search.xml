<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我們真的了解DOM嗎?</title>
    <url>/dom/</url>
    <content><![CDATA[<p>Dom 到底是甚麼呢?<br>其實 Dom 是一個<a class="link"   href="https://www.w3.org/TR/WebIDL/" >定義<i class="fas fa-external-link-alt"></i></a>，是由 W3C WebIDL 所規定，宿主瀏覽器應用程式按此定義實現(底層為 C++)，<br>並且是一種資料結構，存在於<a class="link"   href="https://zh.m.wikipedia.org/zh-tw/WebKit"  title="Webkit">WebKit<i class="fas fa-external-link-alt"></i></a>的記憶體中。</p>
<hr>
<h2 id="瀏覽器如何實現-Dom"><a href="#瀏覽器如何實現-Dom" class="headerlink" title="瀏覽器如何實現 Dom"></a>瀏覽器如何實現 Dom</h2><p>之前提到 DOM 是存在於 Webkit 記憶體中的，而具體操作可以簡略成下圖<br><img  
                     lazyload
                     alt="image"
                     data-src="/images/dom/%E5%85%A7%E9%83%A8%E9%97%9C%E4%BF%82%E5%9C%96.png"
                      alt="內部關係圖"
                ></p>
<h2 id="映射物件和-V8binding"><a href="#映射物件和-V8binding" class="headerlink" title="映射物件和 V8binding"></a>映射物件和 V8binding</h2><p>而瀏覽器透過內部引擎與 WebKit(dom)進行綁定(v8 binding)，建立出一個可以在記憶體中訪問到的 <strong>映射物件(wrapper object)</strong> 。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/dom/bindingV8.png"
                      alt="binding"
                ></p>
<p>v8 與 dom 的<a class="link"   href="https://www.jianshu.com/p/53de5e4deb43" >詳細實現<i class="fas fa-external-link-alt"></i></a>，而我們日常開發中在 devtools 看到畫面並不是 dom，而是<strong>渲染樹</strong>，是 DOM 和 CSSOM 的組合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前兩行執行後， v8 dom wrapper 與 c++ DOM 的綁定關係就完成</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;p&gt;&lt;span&gt;foo&lt;/span&gt;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// 測試下面程式碼</span></span><br><span class="line">div.<span class="property">xxx</span> = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">div = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">lastChild</span>.<span class="property">xxx</span>; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>透過生成 Dom 的 api 會<strong>建立出映射</strong>，並存放在記憶體中，讓我們能夠進行操作，且不會被<strong>GC 回收</strong>。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/dom/DOM%E8%A8%98%E6%86%B6%E9%AB%94%E9%97%9C%E4%BF%82%E5%9C%96.png"
                      alt="記憶體布局"
                ></p>
<p>由此圖我們可以瞭解，只要建造出映射，就算我們取消記憶體位置指向，映射仍會存在，DOM 仍然可以訪問，**<em>若要取消映射，只能透過 DOM api remove</em>**。</p>
<blockquote>
<p>DOM 是 JS 操作頁面的介面，但是 JS 不能直接對 DOM 增刪改查只能透過宿主提供 DOM API 間接操作。</p>
<blockquote>
<p>1.JS 夠過與 DOM 的映射關係操作頁面 2.頁面內容的控制 3.表格、表單資料事件 4.監聽各種使用者互動 5.懶加載其他資源 6.組件化、工程化開發複雜的應用</p>
</blockquote>
</blockquote>
<hr>
<h3 id="那有哪些可以創建元素，建立映射的方法呢"><a href="#那有哪些可以創建元素，建立映射的方法呢" class="headerlink" title="那有哪些可以創建元素，建立映射的方法呢?"></a>那有哪些可以創建元素，建立映射的方法呢?</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="title class_">Element</span>.<span class="property">innerHTML</span></span><br><span class="line"><span class="number">2.</span> <span class="title class_">DOMParser</span></span><br><span class="line"><span class="keyword">var</span> parser = <span class="keyword">new</span> <span class="title class_">DOMParser</span>();</span><br><span class="line"><span class="keyword">const</span> htmlString = <span class="string">&quot;&lt;strong&gt;Beware of the leopard&lt;/strong&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> doc3 = parser.<span class="title function_">parseFromString</span>(htmlString, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"><span class="number">3.</span> <span class="title class_">Document</span>.<span class="property">createElementNS</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElementNS</span>(<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;endition&#x27;</span>)</span><br><span class="line">-&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">endition</span>&gt;</span>​<span class="tag">&lt;/<span class="name">endition</span>&gt;</span></span>​</span><br><span class="line"><span class="number">4.</span> <span class="title class_">Document</span>.<span class="property">createElement</span></span><br><span class="line"><span class="number">5.</span> <span class="title class_">Document</span>.<span class="property">write</span></span><br><span class="line"><span class="number">6.</span> <span class="title class_">Document</span>.<span class="property">createDocumentFragment</span></span><br><span class="line"><span class="title class_">DocumentFragments</span> 是 <span class="variable constant_">DOM</span> 節點(<span class="title class_">Nodes</span>)。他們不會成為 <span class="variable constant_">DOM</span>主幹的一部份，需要append加入 <span class="variable constant_">DOM</span> 樹。</span><br><span class="line"><span class="number">7.</span> <span class="title class_">Document</span>.<span class="property">createTextNode</span></span><br><span class="line">建立文字節點</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Dom-的組成"><a href="#Dom-的組成" class="headerlink" title="Dom 的組成"></a>Dom 的組成</h2><p>標準定義的 DOM 由三大部分構成: 1.節點 2.事件 3.選擇區域(Range AP)</p>
<h3 id="節點-Node"><a href="#節點-Node" class="headerlink" title="節點(Node)"></a>節點(Node)</h3><p><strong>標籤</strong>是 HTML 的基本單位，如:p、div、h1、input 等。<br><strong>節點</strong>是 DOM 的基本單位，一個具有標準結構化模型的文件，有 Element、Text、註解等,共有 12 種節點<a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Node" >MDN<i class="fas fa-external-link-alt"></i></a>。</p>
<p>其中 Element &lt;&#x3D;&gt; HTML 標籤，是互相對應的關係。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello world!<span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>h2 是標籤，在 DOM 內部會生成兩個節點。</p>
<ul>
<li><p>Element Node:h2</p>
</li>
<li><p>Text Node:”hello world!”</p>
</li>
</ul>
<blockquote>
<p>Document 文件<br><strong>指任何一個結構化的文件</strong>：<br>XML Document - 一個 XML 標準模型的文件<br>HTML Document - 一個 HTML 標準模型的文件<br>JSON Document - 一個 JSON 標準模型的文件</p>
<blockquote>
<p><strong>瀏覽器的 document 對象是一個 DOM wrapper object 綁定整顆 DOM 的根</strong>，並掛載於 Global Object 上(如記憶體布局圖)，它們<a class="link"   href="https://www.796t.com/post/YjJ2dWc=.html"  title="dom繼承">互相繼承<i class="fas fa-external-link-alt"></i></a>(document -&gt; HTMLDocument.prototype -&gt; Document.prototype -&gt; Node.prototype)，並可以往上回溯至 object.prototype。</p>
</blockquote>
</blockquote>
<hr>
<h3 id="Element-元素"><a href="#Element-元素" class="headerlink" title="Element 元素"></a>Element 元素</h3><p>屬於程式語言中的語義，在 HTML 中叫 Tag、在 CSS 的表現中稱作 盒 Box。<br>所謂的操作 DOM 就是對 節點 Node 做 增刪改查、監聽、綁事件。</p>
<p><strong><em>Element.prototype</em></strong> 所有元素的共同方法。</p>
<blockquote>
<p>若使用創建元素，建立映射的方法，則該元素的<strong>proto</strong>會指向此原型方法，裡面有各種元素操作函數，標籤各自的特別屬性、不同標籤預設的行為樣式等等。</p>
</blockquote>
<hr>
<p><strong><em>Document.prototype</em></strong> 是 document 的共同方法。</p>
<blockquote>
<p>是一份 xml 文件的根、總稱，掛載了許多 Dom 公共函數，還有瀏覽器的一些訊息(網址、跟引擎相關的 load ready)，html 標籤集合(document.all)等等，它的語義涵蓋 html、dom、文件，因為總總歷史因素，裡面有需多方法跟資料。</p>
</blockquote>
<hr>
<h2 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h2><p>描述 DOM 的一種稱呼，與 DOM 一樣，指 WebKit 記憶體內部的 Object，只不過講 DOM Tree 時，重點是<strong>在樹形結構</strong>，而若是講 DOM 時，則是在對比 JS 中的<strong>Wrapper object</strong>。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/dom/DomTree.png"
                      alt="DOM Tree"
                ></p>
<hr>
<h3 id="NodeList-與-HTMLCollection"><a href="#NodeList-與-HTMLCollection" class="headerlink" title="NodeList 與 HTMLCollection"></a>NodeList 與 HTMLCollection</h3><ul>
<li>NodeList 靜態&#x2F;動態集合，包含所有的 Node 節點 Element、Text、屬性、註解，等 12 種節點(querySelector 系列)</li>
<li>HTMLCollection 動態集合，只有 Element 1 種節點 (getElement 系列)</li>
</ul>
<hr>
<h2 id="重排與重繪"><a href="#重排與重繪" class="headerlink" title="重排與重繪"></a>重排與重繪</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="/images/dom/webkit_render.png"
                      alt="Repaint ReFlow"
                ></p>
<p>頁面生成過程：</p>
<ol>
<li>HTML 被 HTML 解析器解析成 DOM 樹</li>
<li>CSS 被 CSS 解析器解析成 CSSOM 樹</li>
<li>DOM 樹 + CSSOM 樹，生成一棵渲染樹(Render Tree)</li>
<li>生成佈局 (flow)瀏覽器在屏幕上畫出所有節點</li>
<li>將佈局繪製(paint)在屏幕上，顯示出整個頁面</li>
<li>第四步和第五步是最耗時的部分 這兩步合起來，就是我們通常所說的渲染</li>
</ol>
<p><strong>重排&#x2F;回流（Reflow）</strong>：當 DOM 的變化影響了元素的幾何信息，瀏覽器需要重新計算元素大小寬高等屬性，將其安排在正確的位置，就叫重排，為重新生成布局，重新排列。<br><strong>重繪(Repaint)</strong>: 當一元素的外觀產生變化，但没有改變布局,重新把元素外觀繪製出来的過程，叫做重繪。<br><strong><em>任何改變渲染樹的操作都會導致重排或重繪,重排必定重繪</em></strong></p>
<ul>
<li><a class="link"   href="https://csstriggers.com/" >css 重繪<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<hr>
<h2 id="Dom-與-VDom"><a href="#Dom-與-VDom" class="headerlink" title="Dom 與 VDom"></a>Dom 與 VDom</h2><p>直接進行 DOM 操作的會何會影響性能?</p>
<ul>
<li>頻繁的 DOM 操作會導致重排、重繪，會讓瀏覽器在 v8 與 WebKit 兩個 thread 之間來回切換(只能擇一)，</li>
<li>兩個引擎 thread 來回切換就會造成 <strong>「性能損耗」</strong> 。</li>
<li>因此現代框架，為了避免頻繁的操作 DOM 的，自然而然就有了虛擬 DOM 的概念。</li>
</ul>
<p>vDOM 的設計</p>
<ul>
<li>用 JS object 模擬 DOM 就是 vdom (Vue Vnode)</li>
<li>當頁面的數據變動時，產生新的 vdom(vue 副作用 effect 時，響應式產生，Diff 比對)</li>
<li>比較兩個 vdom 的差異(Vue Diff 演算，雙端 Diff，快速 Diff)</li>
<li>差異的部分透過 DOM API 映射到真實 DOM 上(Vue renderer)</li>
</ul>
<h2 id="分類整理-API"><a href="#分類整理-API" class="headerlink" title="分類整理 API"></a>分類整理 API</h2><p>來源 MDN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">---查驗文檔</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="property">readyState</span></span><br><span class="line">  -  屬性描述文件的讀取狀態</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="property">title</span></span><br><span class="line">  - 文檔標題</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="property">visibilityState</span></span><br><span class="line">  - 返回<span class="variable language_">document</span>的可见性, 即当前可见元素的上下文环境. 由此可以知道当前文档(即为页面)是在背后, 或是不可见的隐藏的标签</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---寫文檔</span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">write</span>()</span><br><span class="line">  - <span class="variable language_">document</span>.<span class="title function_">write</span>(markup);</span><br><span class="line">  - 方法将一个文本字符串写入一个由 <span class="variable language_">document</span>.<span class="title function_">open</span>() 打开的文档流（<span class="variable language_">document</span> stream）。</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">--- 全頻相關</span><br><span class="line"><span class="title class_">Document</span>.<span class="property">webkitFullscreenEnabled</span></span><br><span class="line">  - 全屏啟用”屬性指示全屏模式是否可用。</span><br><span class="line"><span class="title class_">Document</span>.<span class="property">webkitIsFullScreen</span></span><br><span class="line">  - 是否在全屏模式。</span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">exitFullscreen</span>()</span><br><span class="line">  - 用于让当前文档退出全屏模式</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">fullscreenElement</span> <span class="comment">//返回当前文档中正在以全屏模式显示的Element节点,如果没有使用全屏模式,则返回null.</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">fullscreenEnabled</span> <span class="comment">//返回一个布尔值,表明浏览器是否支持全屏模式.</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- <span class="title class_">Range</span> 物件</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">createRange</span>()</span><br><span class="line">  -  <span class="title class_">Range</span> 物件。(可用來當富文本切割)</span><br><span class="line">  - <span class="keyword">var</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>();</span><br><span class="line">    range.<span class="title function_">setStart</span>(startNode, startOffset);</span><br><span class="line">    range.<span class="title function_">setEnd</span>(endNode, endOffset);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">caretRangeFromPoint</span>()</span><br><span class="line">  - <span class="keyword">var</span> range = <span class="variable language_">document</span>.<span class="title function_">caretRangeFromPoint</span>(float x, float y);</span><br><span class="line">  - 返回一个 <span class="title class_">Range</span> 对象（指定坐标的文档片段）。</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- 創建類(<span class="title class_">Dom</span>/元素/comment/event)</span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">createAttribute</span>()</span><br><span class="line">  - attribute = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(name)</span><br><span class="line">  - 创建并返回一个新的属性节点</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">createElement</span>()</span><br><span class="line">  - <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tagName[, options]);</span><br><span class="line">  - 创建一个由标签名称 tagName 指定的 <span class="variable constant_">HTML</span> 元素。如果用户代理无法识别 tagName，则会生成一个未知 <span class="variable constant_">HTML</span> 元素 <span class="title class_">HTMLUnknownElement</span>。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line">  - <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  - 创建一个新的空白的文档片段，文档片段存在于内存中，并不在<span class="variable constant_">DOM</span>树中，</span><br><span class="line">  - 所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- 獲取元素資訊</span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">nodeType</span>  <span class="comment">//唯讀屬性表示了節點物件的類型。</span></span><br><span class="line">  -  <span class="variable language_">document</span>.<span class="property">nodeType</span> <span class="number">9</span> (<span class="title class_">Node</span>.<span class="property">DOCUMENT_NODE</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">previousSibling</span> <span class="comment">//返回当前节点的前一个兄弟节点</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">nextElementSibling</span> <span class="comment">// 返回当前元素在其父元素的子元素节点中的后一个元素节点,如果该元素已经是最后一个元素节点,则返回null</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">previousElementSibling</span>  <span class="comment">//返回当前元素在其父元素的子元素节点中的前一个元素节点,如果该元素已经是第一个元素节点,则返回null</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">classList</span> <span class="comment">//唯讀屬性代表了該元素所擁有之類別屬性（Class Attribute）的即時更新集－DOMTokenList。</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">className</span>  <span class="comment">// 获取或设置指定元素的class属性的值。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">innerHTML</span> <span class="comment">// 屬性獲取或設置元素中包含的HTML或XML標記</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">getBoundingClientRect</span>()</span><br><span class="line">  - 返回元素的大小及其相对于视口的位置。</span><br><span class="line">  - 如果是标准盒子模型，元素的尺寸等于width/height + padding + border-width的总和。</span><br><span class="line">  - 如果box-<span class="attr">sizing</span>: border-box，元素的的尺寸等于 width/height。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">querySelector</span>()</span><br><span class="line">  - baseElement.<span class="title function_">querySelector</span>(selectors)</span><br><span class="line">  - 返回与指定的选择器组匹配的元素的后代的第一个元素。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">querySelectorAll</span>()</span><br><span class="line">  - 返回一个non-live的<span class="title class_">NodeList</span>, 它包含所有元素的非活动节点，该元素来自与其匹配指定的<span class="variable constant_">CSS</span>选择器组的元素。</span><br><span class="line">  - baseElement.<span class="title function_">querySelectorAll</span>(selectors);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">cloneNode</span>()</span><br><span class="line"> - <span class="keyword">var</span> dupNode = node.<span class="title function_">cloneNode</span>(deep&#123;<span class="literal">true</span>||<span class="literal">false</span>&#125;); <span class="comment">//如果为true,则该节点的所有后代节点也都会被克隆</span></span><br><span class="line">  - fn 回傳一個呼叫此方法之節點物件的拷貝</span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">contains</span>()</span><br><span class="line">  - <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">contains</span>(node) ex. <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">contains</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>) <span class="comment">//true</span></span><br><span class="line">  - 返回的是一个布尔值，来表示传入的节点是否为该节点的后代节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">getElementById</span>()</span><br><span class="line">  - <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line">  - 返回一个匹配特定 <span class="variable constant_">ID</span>的元素.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">getElementsByClassName</span>()</span><br><span class="line">  - <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(names);</span><br><span class="line">  - 返回一个包含了所有指定类名的子元素的类数组对象。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">getElementsByName</span>()</span><br><span class="line">  -  <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(name)</span><br><span class="line">  - 返回一个在 (X)<span class="variable constant_">HTML</span> <span class="variable language_">document</span>的节点列表集合。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Document</span>.<span class="title function_">getElementsByTagName</span>()</span><br><span class="line">  -  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(name);</span><br><span class="line">  - 返回一个包括所有给定标签名称的元素的<span class="variable constant_">HTML</span>集合<span class="title class_">HTMLCollection</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">getAttribute</span>()</span><br><span class="line">  - align = div1.<span class="title function_">getAttribute</span>(<span class="string">&quot;align&quot;</span>);</span><br><span class="line">  - 函式會回傳該網頁元素的屬性。 如果該屬性不存在，其回傳值會是<span class="literal">null</span>或 <span class="string">&quot;&quot;</span> (空字串);</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">getAttributeNS</span>()</span><br><span class="line">  - 命名空间仅在 <span class="variable constant_">XML</span> 文档中受支持</span><br><span class="line">  - 返回具有指定命名空间和名称的属性的字符串值。如果命名属性不存在，则返回值将为 <span class="literal">null</span> 或 <span class="string">&quot;&quot;</span> （空字符串）</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">getAttributeNames</span>()</span><br><span class="line">  - <span class="keyword">let</span> attributeNames = element.<span class="title function_">getAttributeNames</span>();</span><br><span class="line">  - 返回一个<span class="title class_">Array</span>，该数组包含指定元素（<span class="title class_">Element</span>）的所有属性名称，如果该元素不包含任何属性，则返回一个空数组。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">hasAttribute</span>()</span><br><span class="line">  - element.<span class="title function_">hasAttribute</span>(attName);</span><br><span class="line">  - 返回一个布尔值，指示该元素是否包含有指定的属性（attribute）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- 設定元素</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">attributes</span> <span class="comment">//把特定節點裡所有的屬性變成一個集合,然後回傳出來 // NamedNodeMap 並非一個陣列.attributes 是一個鍵/值的配對</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">toggleAttribute</span>()</span><br><span class="line">  - <span class="title class_">Element</span>.<span class="title function_">toggleAttribute</span>(name [, force]);</span><br><span class="line">  - 切换给定元素的某个布尔值属性的状态（如果属性不存在则添加属性，属性存在则移除属性）</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">setAttribute</span>()</span><br><span class="line">  - element.<span class="title function_">setAttribute</span>(name, value);</span><br><span class="line">  - 设置指定元素上的某个属性值。如果属性已经存在，则更新该值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">before</span>()</span><br><span class="line">  - child.<span class="title function_">before</span>(span);</span><br><span class="line">  - 方法可以在<span class="title class_">ChildNode</span>这个节点的父节点中插入一些列的 <span class="title class_">Node</span> 或者 <span class="title class_">DOMString</span> 对象，</span><br><span class="line">  - 位置就是在<span class="title class_">ChildNode</span>节点的前面，<span class="title class_">DOMString</span> 对象其实和 <span class="title class_">Text</span>节点一样的方式来完成插入的。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">after</span>()</span><br><span class="line">  - <span class="title function_">after</span>(... nodes)</span><br><span class="line">  - 方法会在其父节点的子节点列表中插入一些 <span class="title class_">Node</span> 或 <span class="title class_">DOMString</span> 对象。插入位置为该节点之后。<span class="title class_">DOMString</span> 对象会被以 <span class="title class_">Text</span> 的形式插入。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">append</span>()</span><br><span class="line">  - parent.<span class="title function_">append</span>(p);</span><br><span class="line">  - 在 <span class="title class_">Element</span>的最后一个子节点之后插入一组 <span class="title class_">Node</span> 对象或 <span class="title class_">DOMString</span> 对象。</span><br><span class="line">  - 没有返回值, <span class="title class_">Node</span>.<span class="title function_">appendChild</span>() 返回追加對象</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">prepend</span>()</span><br><span class="line">  - <span class="title class_">Element</span>.<span class="title function_">prepend</span>((<span class="title class_">Node</span> or <span class="title class_">DOMString</span>)... nodes);</span><br><span class="line">  - 在父节点的第一个子节点之前插入一系列<span class="title class_">Node</span>对象或者<span class="title class_">DOMString</span>对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentElement</span>()</span><br><span class="line">  - element.<span class="title function_">insertAdjacentElement</span>(position, element);</span><br><span class="line">  - activeElem.<span class="title function_">insertAdjacentElement</span>(<span class="string">&#x27;afterend&#x27;</span>,div)</span><br><span class="line">  - 将一个给定的元素节点插入到相对于被调用的元素的给定的一个位置。</span><br><span class="line">  <span class="string">&#x27;beforebegin&#x27;</span>: 在该元素本身的前面.</span><br><span class="line">  <span class="string">&#x27;afterbegin&#x27;</span>:只在该元素当中, 在该元素第一个子孩子前面.</span><br><span class="line">  <span class="string">&#x27;beforeend&#x27;</span>:只在该元素当中, 在该元素最后一个子孩子后面.</span><br><span class="line">  <span class="string">&#x27;afterend&#x27;</span>: 在该元素本身的后面.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentHTML</span>()</span><br><span class="line">  -<span class="title function_">insertAdjacentHTML</span>() 把傳入的字串解析成 <span class="variable constant_">HTML</span> 或 <span class="variable constant_">XML</span>，並把該節點插入到 <span class="variable constant_">DOM</span> 樹指定的位置。</span><br><span class="line">  -它不會重新解析被使用的元素，因此他不會破壞該元素裡面原有的元素。</span><br><span class="line">  - element.<span class="title function_">insertAdjacentHTML</span>(position, text);</span><br><span class="line">  - position like top</span><br><span class="line">  - d1.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentText</span>()</span><br><span class="line">  - 将一个给定的文本节点插入在相对于被调用的元素给定的位置。</span><br><span class="line">  - element.<span class="title function_">insertAdjacentText</span>(position, element);</span><br><span class="line">  - position like top</span><br><span class="line">  - para.<span class="title function_">insertAdjacentText</span>(<span class="string">&#x27;afterbegin&#x27;</span>,textInput.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">replaceChildren</span>()</span><br><span class="line">  - <span class="title class_">Element</span>.<span class="title function_">replaceChildren</span>(...nodesOrDOMStrings)</span><br><span class="line">  - 将一个 <span class="title class_">Node</span> 的后代替换为指定的后代集合。这些新的后代可以为 <span class="title class_">DOMString</span> 或 <span class="title class_">Node</span> 对象</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">replaceWith</span>()</span><br><span class="line">  - child.<span class="title function_">replaceWith</span>(span);</span><br><span class="line">  - <span class="title class_">Node</span> 对象或者 <span class="title class_">DOMString</span> 对象，替换了该节点父节点下的子节点 。</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---移除</span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">removeChild</span>()</span><br><span class="line">  - node.<span class="title function_">removeChild</span>(child);</span><br><span class="line">  -從 <span class="variable constant_">DOM</span> 移除一個子節點，並傳回移除的節點。 可刪除被v8binding的 dom映射，立即無法使用且不可挽回。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">replaceChild</span>()</span><br><span class="line">  - parentNode.<span class="title function_">replaceChild</span>(newChild, oldChild);</span><br><span class="line">  - 用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</span><br><span class="line">  - 可探討<span class="variable constant_">DOM</span> binding 還在嗎?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">remove</span>()</span><br><span class="line">  - node.<span class="title function_">remove</span>();</span><br><span class="line">  - 把对象从它所属的 <span class="variable constant_">DOM</span> 树中删除。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">removeAttribute</span>()</span><br><span class="line">  - element.<span class="title function_">removeAttribute</span>(attrName);</span><br><span class="line">  - 指定的元素中删除一个属性。</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location  对象的位置（<span class="variable constant_">URL</span>),含有文檔的 <span class="variable constant_">URL</span> 相關的信息，并提供了改變該 <span class="variable constant_">URL</span> 和加載其他 <span class="variable constant_">URL</span> 的方法。</span><br><span class="line">----</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span> === <span class="variable language_">window</span>.<span class="property">location</span> 接口位置相等</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> <span class="comment">//url整個</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">host</span> <span class="comment">//返回域名(包含port) 192.168.31.121:8080</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">search</span>  <span class="comment">//返回URL参数包含(?)</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">hash</span>   <span class="comment">// 返回標示符URL参数包含(#)。</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">reload</span> <span class="comment">// fn重仔頁面資源</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">replace</span> <span class="comment">// fn 用給定的URl跳轉至該頁面，不會有紀錄</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可設定功能類型</span><br><span class="line">---</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">designMode</span> <span class="comment">// 控制整個文件是否能夠編輯 = &quot;on&quot; || &quot;off&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">dir</span> <span class="comment">// 文档的文字朝向 = &#x27;ltr&#x27; || &#x27;rtl&#x27;</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="參考資料及引用"><a href="#參考資料及引用" class="headerlink" title="參考資料及引用"></a>參考資料及引用</h2><ul>
<li><a class="link"   href="https://bitsofco.de/what-exactly-is-the-dom/" >What, exactly, is the DOM?<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.gushiciku.cn/pl/gFY6/zh-tw" >Virtual DOM<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/question/324992717/answer/707044362" >前端为什么操作 DOM 是最耗性能的呢？<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.jianshu.com/p/53de5e4deb43" >v8<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.zhihu.com/question/269333790/answer/350467595" >document 与 element 上的函数为什么不是一个?<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://html5.tool.webfrontend.dev/" >HTML 標籤週期表<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/111testing/p/11186335.html" >渲染過程<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://chromium.googlesource.com/chromium/src.git/+/62.0.3178.1/third_party/WebKit/Source/bindings/core/v8/V8BindingDesign.md" >chorme BindingDesign<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>document</tag>
      </tags>
  </entry>
  <entry>
    <title>前端與框架的關係</title>
    <url>/frameWork/</url>
    <content><![CDATA[<h1 id="前端與框架的秘密"><a href="#前端與框架的秘密" class="headerlink" title="前端與框架的秘密"></a>前端與框架的秘密</h1><h2 id="前言-JS-誕生與戰國時代"><a href="#前言-JS-誕生與戰國時代" class="headerlink" title="前言: JS 誕生與戰國時代"></a>前言: JS 誕生與戰國時代</h2><p>1995 年 JavaScript 誕生，<strong>布蘭登·艾克 Brendan Eich</strong>只花了 <span style="color:red;">10 天</span> 時間設計出 JavaScript 語言。<br>而那時正處於瀏覽器的戰國時代，各家瀏覽器都有自己的 JS 規格。語法的實現不一，常常造成困擾，為了兼容都塞在 window 屬性裡，現今印出 window 的屬性，也有許多歷史的痕跡。直到後來才有了 ECMA 組織訂出了標準。</p>
<!-- ### JS 的爸爸 -->

<!-- ### 混亂的 Window -->

<h2 id="jQuery-的大統一"><a href="#jQuery-的大統一" class="headerlink" title="jQuery 的大統一"></a>jQuery 的大統一</h2><p>2006 年，jQuery 發布了，當時前端面對的是瀏覽器兼容性問題(瀏覽器戰爭遺毒)，jQuery 在處理 DOM 兼容上，開發出大量的 DOM&#x2F;BOM 兼容方案，並且相當的輕量，還使用了鏈式連結，提供開發者們快捷的開發方式，並能開發出更穩定的應用，導致被大量地使用。而這也是間接導致前後端分離的原因之一。<br>但我們並不能稱 jQuery 是一個框架，它只是一個<strong>library 函式庫</strong>，但它是前端框架的啟蒙者。</p>
<h2 id="JS-與-jQuery-的差異"><a href="#JS-與-jQuery-的差異" class="headerlink" title="JS 與 jQuery 的差異"></a>JS 與 jQuery 的差異</h2><p>JS</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> checkValue;</span><br><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(‘input’);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; elements.<span class="property">length</span>; n++)&#123;</span><br><span class="line"><span class="keyword">if</span> (elements[n].<span class="property">type</span> == ‘radio’ &amp;&amp; elements[n].<span class="property">name</span> == ‘<span class="title class_">RadioGroup</span>’ &amp;&amp; elements[n].<span class="property">checked</span>)&#123;</span><br><span class="line">checkedValue = elements[n].<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jQuery</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> checkValue = $(‘[name=”radioGroup”]:checked’).<span class="title function_">val</span>();</span><br></pre></td></tr></table></figure>

<h2 id="jQuery-的消逝與退場"><a href="#jQuery-的消逝與退場" class="headerlink" title="jQuery 的消逝與退場"></a>jQuery 的消逝與退場</h2><p>隨著網頁應用的越加廣泛，頁面邏輯也就越加複雜，jQ 的優勢也漸漸的消逝，為了開發越加複雜的應用，開發者必須新增不同功能的 jQ 庫，來解決開發複雜頁面所遇到的問題，慢慢地成為開發者的負擔。雖然不斷有新的 library 出世，但一直沒有人可以取代 jQ，一直到 2010 年的 Angular 被提出，一個新的想法，「前端框架」的概念才橫空出世。</p>
<h1 id="何謂框架的概念，框架又是為了解決甚麼問題"><a href="#何謂框架的概念，框架又是為了解決甚麼問題" class="headerlink" title="何謂框架的概念，框架又是為了解決甚麼問題?"></a>何謂框架的概念，框架又是為了解決甚麼問題?</h1><p>要回答這個問題，我們需要回到業務模型開始分析</p>
<p><strong>web1.0</strong>: MVC 模型開發應用，頁面顯示和邏輯功能都綁定再一起，前後端並未進行明確的職責分工，也就是說一個頁面中會混入不同的語言邏輯。</p>
<p><strong>web2.0</strong>: AJAX 技術的出現，前端透過 AJAX 非同步方式來獲取資料，並使用 jQ 展現頁面及邏輯操作，後端透過提供 Api 接口，此合作方式將頁面與資料分離，這也是最初的前後端分離雛形！但仍是 MVC 的模型。</p>
<h2 id="舊有的業務模型-MVC"><a href="#舊有的業務模型-MVC" class="headerlink" title="舊有的業務模型 MVC"></a>舊有的業務模型 MVC</h2><p>模型（Model): 工程師編寫程式應有的功能、資料庫進行資料管理和資料庫設計。（實現演算法，實現頁面功能等等…）<br>視圖（View):圖形介面設計，也就是客戶端頁面。<br>控制器（Controller):負責轉發請求，對請求進行處理後，通知 model。</p>
<h2 id="新的業務模型-MVVM"><a href="#新的業務模型-MVVM" class="headerlink" title="新的業務模型 MVVM"></a>新的業務模型 MVVM</h2><p>Model: 代表數據模型。<br>View: 用戶操作介面。<br>ViewModel： 業務邏輯層。</p>
<p>簡單來說，MVVM 可以讓業務邏輯反映在頁面上，邏輯層又與數據層雙向綁定，達到互相連動的效果。</p>
<p><strong>MVVM 就是框架的概念，簡化數據與 UI 頁面的依賴，也解決了數據頻繁更新的問題</strong>，<br>開發者不用再依賴一堆 jQ 套件，前端不需要再把邏輯和頁面混在一起做撒尿牛丸，資料實時反映在 view 上，後端不需要再對前端頁面進行加工，降低開發者們的精神負擔,達到各端專注分工的合作模式。</p>
<!-- # MVC 與 MVVM 資料夾架構差異 -->

<h1 id="框架御三家"><a href="#框架御三家" class="headerlink" title="框架御三家"></a>框架御三家</h1><p><strong>React</strong> 開源於 2013 年 5 月，目前有 196K 星數，爸爸是 FB。<br><strong>Angular</strong> 開源於 2009 年，目前有 84.4K 星數，爸爸是 Google。<br><strong>Vue</strong> 開源於 2014 年，200K 星數，創作者是尤宇溪，目前沒有爸爸。<br>三大框架都有各自的愛好者，學習成本為 Angular&gt;React&gt;Vue。</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p><code>UI = fn(state)</code><br>React 的核心思想，頁面可以靠著抽象的函式包覆狀態後產生 UI，也就是 UI 是將數據投影到不同形式的函式中。相同的輸入提供相同的輸出。維持純粹且簡單的使用方法。</p>
<p>目前版本為 18 版本，16.8 版本後引入 Hook Api ，能更好的控制副作用及進行狀態管理，並將生命週期的概念移除，使用統一的流管理函式，可將依賴抽象化，合理地控制渲染流程，降低開發人員的心智負擔，但需要對 Js 有一定的理解，才能方便的操作。</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>三大框架中最年輕的一個，也最綜合的一個。</p>
<p>Vue 核心分為<code>聲明式的描述UI，渲染器，組件，編譯器</code>。</p>
<p>各個核心相互依賴，構成了一個比 React 更為複雜的框架，框架本身進行了許多優化處理，結合其餘框架的精華，有生命週期，有 hook 式的使用方法，有 Class optional 的使用方式，有 Fn composition 的組合方式，官方檔案文件齊全，開法上手快速，擁有許多框架語法糖供開法者使用，也提供了 JSX 的撰寫模式，讓你寫近乎原生的 JS。</p>
<p>簡單來說，就是要什麼有什麼，甚麼都碰一點~</p>
<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>最古老且完整的框架</p>
<p>基於 TypeScript 進行開發，具有完整且龐大的依賴體系庫，指令式的開發模式及組件切分的概念被眾多框架仿效，學習成本陡峭，已與許多良好的開發模式可以依循，大型且需要高穩定度的網站，多使用此框架。</p>
<!-- # 2021 年度 框架滿意度及使用度 -->

<h1 id="後起之秀（學不完的框架）"><a href="#後起之秀（學不完的框架）" class="headerlink" title="後起之秀（學不完的框架）"></a>後起之秀（學不完的框架）</h1><p><strong>Svelte</strong> 是一種全新的構建用戶界面的框架。Svelte 有別於傳統框架，它將大量的優化工作放到了構建應用程序的編譯階段來處理。<strong>無虛擬 DOM，無須添加狀態管理工具</strong></p>
<p><strong>SolidJS</strong> 用於在 Web 上構建快速的聲明式 UI。它<strong>與 React 共享許多想法</strong>，但不使用虛擬 DOM 來提供更高效和更實用的開發人員體驗。</p>
<p><strong>Qwik</strong> 類似 react 的前端 ssr 框架，大幅優化甚至取消了 hydration 的過程，不光是延遲加載組件，還可以延遲加載點擊事件等代碼，幾乎可以做到， 只加載當前用到的 js 代碼與 css 代碼，dom 元素沒有出現在屏幕的可視區，則不執行組件內部方法。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>各框架為了解決日益複雜化的前端應用問題，演化出了不同的核心想法，有自由無限制的控制模式，也有規定繁雜的設計概念，隨著瀏覽器引擎的進化，前端框架勢必隨著更新，觀察框架也是在觀察前端的脈動，前端工程在這些思想的衝擊下，也會越加發展成熟茁壯。</p>
<p>參考資料：</p>
<p><a class="link"   href="https://javascript.alphacamp.co/javascript-past-and-present.html" >Js 起源與前世<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://kknews.cc/tech/vlypb5l.html" >盤點 Web20 年<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.notion.so/b9059106045a4432a2f697402372126e#29689bd6e5954a1f979289312dcdbd6f" >前端框架演進之路<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.kn8.lt/blog/ui-is-a-function-of-data/" >UI is a function of state<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://2021.stateofjs.com/zh-Hant/libraries/front-end-frameworks/" >Front-end frameworks and librariese<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zhuanlan.zhihu.com/p/445122206" >如何利用 Qwik 和 Partytown 削减掉 页面中 99% 的 JavaScript <i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>framework</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端轉職很簡單？</title>
    <url>/frontend-001/</url>
    <content><![CDATA[<p>最近與朋友聊天,被詢問到為什麼想要轉職,從外文轉換到工程師的過程,是不是很痛苦？<br>要回應時竟一時語塞,只能微笑帶過,回說真的蠻困難的…<br>於是有了想要把轉職的過程,思維轉換的過程,記錄下來的想法.</p>
<h2 id="為什麼想要轉職？"><a href="#為什麼想要轉職？" class="headerlink" title="為什麼想要轉職？"></a>為什麼想要轉職？</h2><p>本身私大日文系畢業,大學時期及畢業後工作階段,完全沒有碰過任何程式邏輯,連有前端這個職缺都不知道的無關人士.<br>轉職前的我過著全台跑客戶的業務生活,每天不是迎合老闆就是陪客戶拉單的日子,看著這樣的每天,打從心底有了一個厭煩的感覺,<strong>好想脫離這樣的生活</strong>,剛好遇到轉職成功的朋友,小聊了一下覺得好像工程師也不錯耶!!<br>坐在辦公室吹冷氣,寫程式切版面,薪水又高,好爽的感覺～<br>是的,那時的我並沒有做任何的研究,就只是一個想跳脫固有框架,過爽日子的簡單想法😆</p>
<h2 id="去哪裡轉職？"><a href="#去哪裡轉職？" class="headerlink" title="去哪裡轉職？"></a>去哪裡轉職？</h2><p>基於自己的性格以及朋友提供的故事,知道自己沒有一個鞭策的動力,一定是不會主動學習,也不知道該行業別的先備知識,應該是無法成功的,所以首先自學這條路基本上沒考慮過…<br>評估過六角的課程,資策會養成班,以及其他線上課程,最後還是選擇了<a class="link"   href="https://www.tibame.com/goodjob/frontend_taipei" >養成班<i class="fas fa-external-link-alt"></i></a>,也就是業界戲稱的「速成量產班」,<br>半年為一期,報名費高昂,但學長姐們的網頁寫的都很好看,好像很好入門,報名時被詢問是否<strong>真的對前端有興趣</strong>,<br>那時對前端這個概念基本上為0,就草草的回答有😇.<br>現在回想起來,基本上就是個沒有思考的蠢蛋…</p>
<blockquote>
<p>建議真的要經過謹慎的評估,及多方詢問再決定轉職方式,若真的沒有業界人士可以詢問,也可以詢問我.</p>
</blockquote>
<h2 id="轉職的學習過程"><a href="#轉職的學習過程" class="headerlink" title="轉職的學習過程"></a>轉職的學習過程</h2><p>一開始學習HTML+CSS,覺得還行,就跟背書一樣,把CSS屬性 HTML tag記下來,感覺沒什麼大不了的,對盒模型,flex黑魔法,grid佈局,render flow,時間因素下,課程就是只能帶過,硬記下來也就過了,但到了Js直接崩潰,有種老師到底在說什麼的感覺,var let const 函式 閉包 callback loop condition,每天資訊量都過載,<em><strong>感覺大腦在顫抖</strong></em>.</p>
<p>基於js的壓力,課堂上的同學們開始抱團,互相詢問,但作業直接抄同學程式碼的人也是大有人在~<br>於是我開始思考,到底要怎麼脫離這個循環,這樣下去真的會轉職成功?我連程式都寫不出來,有種挫折＋失敗的混沌想法,塞滿了我的腦海,但那時有一位同學跟大家都不一樣,大家還在寫第三題時,總是快了大家兩到三步,我覺得很神奇,詢問下才知道,還在學HTML時,她就趁著課餘的時間學習js了,還去補了線上課程的切版班!</p>
<p>「怎麼可以這麼強！是妖怪吧！」,於是我開始模仿她的做法,盡量的壓縮休息時間,看書看線上課程,才知道之前的自己有多廢…<br>學習程式需要大量實作及不斷地更新正確知識,才有機會學好,只靠老師課堂上的簡單練習,及同學們的程式碼是非常危險的一件事,<br>當課程進行到前端框架時,自己已經先打了預防針,知道要做什麼,怎麼學習.<br>至今,由衷的感謝那位同學,若沒有看到當時她的努力,驚醒了我,根本不會走到現在的程度.</p>
<p>最後的團體專題時,被選為組長,老師說會有很多負擔,但我想如果多做了這些東西,是不是代表我會多學到東西呢?是不是比別人多了可以展現的資本呢？<br>團專真的很累人,除了要顧自己的產出外,還要監督大家的進度,git有沒有人亂推解衝突,打包上版,也是各種開夜車的每天,<br>好不容易順利Demo作品,又遇到了另一個難題,找工作…..</p>
<p>&lt;下一篇&gt;</p>
<p>前端關鍵字:HTML CSS Javascript 前端框架 css預處理 url輸入後瀏覽器做了什麼 git</p>
]]></content>
      <categories>
        <category>FrontendNote</category>
      </categories>
      <tags>
        <tag>Frontend</tag>
        <tag>small talk</tag>
      </tags>
  </entry>
  <entry>
    <title>轉職前端前，你可能會想知道?</title>
    <url>/frontend-002/</url>
    <content><![CDATA[<p>在搜尋引擎中，打下關鍵字[前端，轉職]往往會出現非常多的資訊，難免會有些補習班的廣告及年份已經過期的資料，故想要將自己知道的業界資訊分享給想要轉職前端的夥伴們，希望可以節省一些大家找資料和過濾正確性的時間，並讓轉職者們對前端有簡易的認識。</p>
<blockquote>
<p>保持滾動式的持續更新 😆…</p>
</blockquote>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在轉職之前，你可能會懷抱對軟體業過度美化的想法，或看到程式補習班打出轉職後高薪 XXk 等標語，但實際上，能轉職後馬上找到高薪的工作，要不是你頗具慧根、相關科系、有額外加分條件等…，通常都是 35k~45k 起跳(<strong>32k 的鬼故事 🫣，筆者也是常聽到</strong>)，若要更高要往博弈業、區塊鏈走，但好不好走，適不適合，做膩了能否回歸，就又是另一回事了。</p>
<hr>
<h2 id="軟體業有哪些職缺"><a href="#軟體業有哪些職缺" class="headerlink" title="軟體業有哪些職缺?"></a>軟體業有哪些職缺?</h2><p>目前軟體業有許多的職缺，常聽到的有前後端工程師，app(安卓|蘋果)開發工程師，測試工程師，程式架構師，UI&#x2F;UX 設計師，網頁設計師，infra，AI 工程師等，SA，產品經理，大數據，全端開發工程師等。每個職能都是專業且會互相影響的，在產品的開發當中，會依照產品鎖定客群及公司策略，選擇組成的開發團隊人數及職能分佈。</p>
<p>ex.今天決定要開發 web 產品，最基本組成&#x3D;&gt; UI&#x2F;UX ＋前&#x2F;後端＋ PM，若在大一點的公司就會有 SA 及測試工程師，來維持專案的進程及測試開發中產品是否能正常運行，人數的多寡會依照產品規模的成長增加。產品的上線(發布)則會有部署工程師(maybe 後端)+infra 來協助部署，當然還有許多合作上的細節，之後有提到時會在補充.</p>
<ul>
<li><a class="link"   href="https://forum.gamer.com.tw/C.php?bsn=60561&snA=19606" >前端相關淺談<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.yourator.co/articles/283" >詳細的職缺敘述<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<hr>
<h2 id="來談談非本科轉職的優缺點吧！"><a href="#來談談非本科轉職的優缺點吧！" class="headerlink" title="來談談非本科轉職的優缺點吧！"></a>來談談非本科轉職的優缺點吧！</h2><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><h4 id="原先的產業知識"><a href="#原先的產業知識" class="headerlink" title="原先的產業知識"></a>原先的產業知識</h4><p>假設非本科的我們，在轉職前對原先職能有一定程度的理解，那我們的優勢就是原產業的知識（domain know-how)，若再轉職後，投遞相關產業可能有意想不到的加分效果，在面試表現時可以有更深度的回答及反饋，但也有可能根本不想回到原行業…😤</p>
<p>ex.轉職前為旅遊業的客服人員，轉職後又進了大型旅遊公司的開發團隊，那對整體的業務流程會有一定程度的了解，在程式開發上就能節省一些理解程式邏輯的時間成本，也能跟 User 或是產品經理提出意見，進行討論時能對於問題提出精確的描述~</p>
<h4 id="換位思考"><a href="#換位思考" class="headerlink" title="換位思考"></a>換位思考</h4><p>這標題並不是說只有非本科才有換位思考的能力，而是<strong>希望非本科轉職能有這個能力</strong>，畢竟我們轉職前是各種網站的使用者(YAHOO、GOOGLE、MOMO)，而今天我們轉職成了工程師，我們從原先的使用者為主的思考模式必須轉換成開發者的角度。</p>
<p>ex.使用者自然希望一個鍵按下去能做完所有他關注的事物，但開發的角度我們則不然，我們可能會針對程式邏輯的組合提出疑問!(可能是兩種對立的觀點，我們要如何去調適這個轉換？)</p>
<h4 id="溝通及合作能力"><a href="#溝通及合作能力" class="headerlink" title="溝通及合作能力"></a>溝通及合作能力</h4><p>最重要的一點就是溝通及合作，<strong>邏輯可以培養</strong>，<strong>技術可以進公司再來慢慢學</strong>,但合作及溝通，從 0 開始要培養是非常困難的，大家可能覺得工程師不是按照上級指令開發，或是看看需求單開發就好了嗎?為什麼要溝通呢？<br>當然公司只有你一個人時自然不需要溝通，但若是在一定規模的公司上班，你配合的不是一兩個人而已，可能是好幾個團隊，每天都有會議要開，需求要確認，這時溝通與表達能力，自然而然地比重上升許多～，下方的描述開發流程區，就能體現為何溝通能力重要了 😵‍💫</p>
<h3 id="缺點（可能遭遇的問題"><a href="#缺點（可能遭遇的問題" class="headerlink" title="缺點（可能遭遇的問題)"></a>缺點（可能遭遇的問題)</h3><p>缺乏軟體業相關技術知識，套入先前行業別的模式處理開發事務，對整體開發流程不熟悉，無法順利以術語表達需求(無法順利溝通)，找不到技術搜尋關鍵字怎麼下，功能不會開發，對未知事務的恐慌等等…，會有這些問題都很正常的，筆者也面對過這些問題。</p>
<ul>
<li><p>前端知識: 對於前端而言的最基礎的知識就是 HTML+CSS+JavaScript(御三家)，之於人體即是&#x3D;&gt;人體骨幹＋表皮＋肌肉神經， 好的可互動網頁這三項缺一不可，進階一點就會往框架方向加深(Js 一定要學好再碰)，常見的前端框架(Vue，React，Angular，Svelte)，框架簡略來說是為了簡化開發人員的精神負擔及節省開發時間，類比的話就是你可以走路從台北到高雄(原生 Js)，也可以選擇搭飛機(框架)。</p>
<blockquote>
<p>更底層一點的知識:網頁渲染流程、SEO、效能優化、SOLID 的程式碼架構及邏輯可循的撰寫模式、SPA、SSR、孤島架構、演算法、計算機概論 等…，你可以都不懂，但好薪水的工作都希望你能懂 QQ</p>
</blockquote>
</li>
<li><p>整體開發流程: 以筆者目前經歷過的開發流程有兩種，以公司型態的不同有所區分，大家可以簡單參考一下。</p>
<blockquote>
<p>1.接案公司：公司會以案件的大小及客戶給的開發時程評估這次有組隊的人選(PM+前後端+UI&#x2F;UX)，一開始會討論專案進行的方式，客戶的目標(產品要做什麼)，並開始使用者訪談，確認專案的細節及核心邏輯，確認客戶一定要做的功能。通常一開始客戶會有各種天花亂墜的想法，我們就是要去限制他，哪些是技術上可以做的，<strong>哪些你就算把錢丟在我臉上，也是做不到的 XD</strong>，通常訪談會來回個兩三次，工程師則利用這個空擋去 survey 要用在專案的技術，及開始佈建一些基礎邏輯，方便使用者定案後，可以馬上開始開發。一但確認後，等 UI&#x2F;UX 開始出稿件(前端需要依照稿件規格開發產品)，前端會一邊進行稿件開發以及與後端 api 的介接(真實資料的串連)，客戶若有變更或新的需求提出，則會回退至討論及設計，等待確認再回給前端開發，不斷往復，等到整體稿件及邏輯介接完成後，就可以進行產品測試及發布。</p>
</blockquote>
<p>簡單的流程: 使用者討論會談&#x3D;&gt; UI&#x2F;UX 設計&#x3D;&gt;前後端開發&#x3D;&gt;使用者變更&#x3D;&gt;回到 2 步驟&#x3D;&gt;專案測試及發布&#x3D;&gt;上線好棒棒！<br>通常開發時程不長，且以客戶為主體，開發的發言權不高.（薪水也不高 🤫）</p>
<hr>
<blockquote>
<p>2.專案公司（自有產品）：流程架構則會以 PM、SA 去跟 User 訪談，等確認要做哪些核心邏輯後，拉 UI&#x2F;UX 及開發團隊進入會議一起討論，若有問題則在會議上馬上提出，UI&#x2F;UX 會在會議中 DEMO 頁面流程等，與使用者確認，使用者提出新需求，UI&#x2F;UX 更正後會再另外發出會議，此流程會消耗較多的時間，再討論流程及頁面元素上，PM 及 SA 也會提供一些建議，協助開發者找尋技術方向，並在會議中限縮使用者的發想，開發順序則依照頁面上線排程進行安排，然後樸實無華的 UI&#x2F;UX 出稿&#x3D;&gt;前端開發頁面&#x3D;&gt;後端出 api&#x3D;&gt;前端串接&#x3D;&gt;測試&#x3D;&gt;上版&#x3D;&gt;QA 測試&#x3D;&gt;確認上線</p>
</blockquote>
<p><a class="link"   href="https://medium.com/codingbar/api-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC-%E7%94%A8%E7%99%BD%E8%A9%B1%E6%96%87%E5%B8%B6%E4%BD%A0%E8%AA%8D%E8%AD%98-95f65a9cfc33" >api 是什麼？<i class="fas fa-external-link-alt"></i></a></p>
<p>當然每家的流程都有不同，筆者僅以自身經歷提供簡略描述，在產品公司工作，則會有較多的時間餘裕，並且開發的發言權也有一定被採納的空間。</p>
<hr>
</li>
<li><p>技術搜尋關鍵字怎麼下: 描述你享用的技術要拿來做什麼，或是要做什麼。<br>ex. Js array methods to slice item ， CSS overFlow website ， 我的網頁 404 怎麼辦？</p>
</li>
<li><p>未知事務的恐慌: 開始轉職後，常常會擔心自己學的不夠多也不夠深，在開發上也常常四處碰壁，開到課程就想買，朋友推薦的書也想看，會擔心及恐懼自己不夠好。但事實上我們只要保持腳步持續進行就好，今天遇到什麼困難解決就好，不要放大恐慌性的思想，一切都會度過，然後遇到新的難關，再次挑戰並度過，只要保持好心態，持續進步都會度過的~</p>
</li>
</ul>
<h2 id="工作型態"><a href="#工作型態" class="headerlink" title="工作型態"></a>工作型態</h2><h3 id="接案公司類"><a href="#接案公司類" class="headerlink" title="接案公司類"></a>接案公司類</h3><p>大部分接案公司都是中小型企業(1~50 人)，當然有例外，例如資拓、緯創等，通常開發模式以公司案件報價計酬，接越多賺越多(前提是能在時限內完成)，敏捷開發抑或是隕石開發 🤯，技術上會採用較新的技術，畢竟案主可能會有很多突發奇想 XD，挑戰力高，成長速度較快，有機會成為全端一條龍，若對自己能力有保握，可以試試。</p>
<blockquote>
<p>削價競爭，壓榨工程師開發時間的公司，也是略有耳聞，當然也有幸福企業，不以偏概全。</p>
</blockquote>
<h3 id="新創產品類"><a href="#新創產品類" class="headerlink" title="新創產品類"></a>新創產品類</h3><p>快速迭代技術的類別，人數也不會太多（50 人上下)，公司很吃產品視野及老闆腦袋，需要常常更新版本，以達到快速拓展業務、開闢客戶、急速發展的宗旨，開發時程快速，但薪水也較優渥，容易被看見，升職或升薪幅度也較大。<br>建議可以挑自己喜歡的產品類別，新創起來才會更有動力，加班也更有…</p>
<blockquote>
<p>沒選好，可能會落得蠟燭兩頭燒。</p>
</blockquote>
<h3 id="產品公司類"><a href="#產品公司類" class="headerlink" title="產品公司類"></a>產品公司類</h3><p>開發時程較為緩慢，不需要負擔公司賺錢壓力，若在團隊架構較大較完整的公司，可以完整學習開發流程，從開發&#x3D;&gt;測試&#x3D;&gt;部屬&#x3D;&gt;上線的迴圈，學習每個環節需要的技術能力，但通常越完善的公司，面試起來的難度也會越高，對轉職新手較不友善，通常要等多開缺比較有機會進入。(筆者較為推薦)</p>
<blockquote>
<p>但也有可能進入養老公司，沒有保持進步，反而被公司綁住。</p>
</blockquote>
<h3 id="外商公司類"><a href="#外商公司類" class="headerlink" title="外商公司類"></a>外商公司類</h3><p>通常進去就發達了 XD，需要一定的外語能力(口說及閱讀)，此類也較多遠端缺額，但職缺通常都比較少公布，若有人脈會比較好進入，也能解省外商面試的時間。</p>
<p><a class="link"   href="https://www.hexschool.com/2022/06/23/2022-06-23-software-engineer-salary/" >參考薪水<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://guide.104.com.tw/salary/cat/2007001000?type=catjobs&salary=monthly" >104 薪水<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>薪水參考價值居多，多面幾間公司，多談多比較，每年都出來試水溫，更有機會談到好薪水。</p>
</blockquote>
<hr>
<h2 id="有哪些學習資源"><a href="#有哪些學習資源" class="headerlink" title="有哪些學習資源?"></a>有哪些學習資源?</h2><p>以下會推薦一些筆者覺得不錯的學習資源，並會描述使用哪些技術。</p>
<ul>
<li><p>中文 youtuber: Alex 宅幹嘛[Vue 框架] ， Tommy 騎巴哥[JavaScript] ， Code Learning | 编程教程[底層知識] ， 布魯斯前端[React]， loyiCodes[資料結構]， 在地上滾的工程師 Nic[開發者的心態]，Web 實驗室[網路運作，底層知識] ， Mike Cheng[Vue]，CSScoke[CSS]，Jomy King[JavaScript，綜合前端技術]</p>
</li>
<li><p>國外 youtuber: Online Tutorials[CSS 動畫特效]，codeSTACKr[前端 RoadMap]，LearnCode.academy[JavaScript]，CrashCourse[資料結構]，NetworkChuck[Linux]，ByteByteGo[網頁底層]，HackBear 泰瑞[國外的開發者簡述生活]，<a class="link"   href="https://github.com/JoseDeFreitas/awesome-youtubers" >awesome-youtubers<i class="fas fa-external-link-alt"></i></a> &#x3D;&gt; 集結各種優質頻道</p>
</li>
<li><p>udemy hahow hiskio 開發技術學習平台:網頁開發全端攻略｜零程式基礎也適用，JavaScript + Vue3，JavaScript 全攻略：克服 JS 的奇怪部分，The Complete JavaScript Course 2022: From Zero to Expert!，The Complete 2022 Web Development Bootcamp</p>
</li>
<li><p><a class="link"   href="https://roadmap.sh/frontend" >RoadMap<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>書本: JavaScript 犀牛書，鐵人幫入門系列等，網站互動設計進化之道。</p>
</li>
<li><p>github: <a class="link"   href="https://github.com/7-sevens/Developer-Books" >Developer-Books<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/jCodeLife/mind-map" >mind-map<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/geekxh/hello-algorithm" >针对小白的完整的算法训练流程<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/FrontEndGitHub/FrontEndGitHub" >FrontEndGitHub<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/lgwebdream/FE-Interview" >FE-Interview<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/kujian/frontendDaily" >frontendDaily<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>若有好的學習資源推薦,非常歡迎在下方留言 🙌</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="轉職成功，就是結束"><a href="#轉職成功，就是結束" class="headerlink" title="轉職成功，就是結束?"></a>轉職成功，就是結束?</h2><p>轉職成功絕非結束，是漫漫長路的開始，為了解決不同的需求，前端百家爭鳴，各種新舊技術交雜，我們都需要不斷的溫故知新，不要排斥學習，因為這條路，只有不斷的學習，才能讓你更加精進。也不要停止與業界人士交流，不論是公司同事或是只有一面之緣的技術論壇朋友，維持好的人際網路，會對未來的旅途有意想不到的加分效果，開始記錄你遇到的技術難點及筆記，也許在哪場面試中，就幫了你一把，也不要停止追尋更好的自己，畢竟轉職就是對自己的人生有所覺悟的體現，我們都值得更好的未來。</p>
]]></content>
      <categories>
        <category>FrontendNote</category>
      </categories>
      <tags>
        <tag>Frontend</tag>
        <tag>small talk</tag>
        <tag>前端轉職</tag>
        <tag>前端學習</tag>
      </tags>
  </entry>
  <entry>
    <title>實作一個可視區域導讀提醒</title>
    <url>/frontend-003/</url>
    <content><![CDATA[<p>在前端的開發過程中，常需要在某個視覺區塊進入頁面的可視範圍時，讓頁面進行某些變化，我們會使用一些第三方的套件庫，但第三方的套件庫可能相當龐大，或是使用上來說並沒有那麼直覺，那有沒有其他更便利方法呢？</p>
<h1 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a>Intersection Observer</h1><p>原生的 Api，可以用來觀測頁面元素與可見區域相交部分的比例，然後可以在達到比例時觸發 callback。<br>常被用來在圖片的 lazyLoading，內容的無限滾動，及自動播放影片或音檔等功能。</p>
<h2 id="參數"><a href="#參數" class="headerlink" title="參數"></a>參數</h2><p><code>IntersectionObserver(callback， options)</code>  接受兩個參數：</p>
<ul>
<li><code>callback</code>： 當指定重疊條件發生時要執行的 callback 函式。</li>
<li><code>options</code>：<ul>
<li><code>root</code>：欲觀察的 root 元素，不特別指定或是  <code>null</code>  時等於瀏覽器的可視範圍 (browser viewport)。</li>
<li><code>rootMargin</code>：用來改變 root 元素觀察的範圍。</li>
<li><code>threshold</code>：Target(目標元素) 的可見程度。可帶入浮點數或浮點數的 array，ex <code>[0， 0.25， 0.5， 0.75， 1]</code>，每當 target 的可見程度高於 threshold 時，<code>callback</code>  就會被頻繁地觸發， 也就是每 25% 或者减少 25% 的时候都通知一次。可看需求變動。</li>
</ul>
</li>
</ul>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>),</span><br><span class="line">  <span class="attr">rootMargin</span>: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">0.5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#listItem&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="實際使用案例"><a href="#實際使用案例" class="headerlink" title="實際使用案例:"></a>實際使用案例:</h1><p>筆者希望能夠模擬出閱讀網站的功能，即在當前閱讀區域時，可以在 menu list 標記閱讀區塊及變動 URL。</p>
<blockquote>
<p><code>實現程式碼使用 vue3，可貼上下方程式碼，觀看變化 </code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style &gt;</span><br><span class="line">    *&#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">      list-style: none;</span><br><span class="line">      box-sizing: border-box</span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">      display: flex;</span><br><span class="line">      justify-content: center;</span><br><span class="line">      align-items: center;</span><br><span class="line">      background: #aaa;</span><br><span class="line">    &#125;</span><br><span class="line">    .container&#123;</span><br><span class="line">      height: 2500px;</span><br><span class="line">    &#125;</span><br><span class="line">    h1&#123;</span><br><span class="line">      font-size: 5rem;</span><br><span class="line">    &#125;</span><br><span class="line">    p&#123;</span><br><span class="line">      font-size: 1rem;</span><br><span class="line">      line-height: 2;</span><br><span class="line">    &#125;</span><br><span class="line">    .menu&#123;</span><br><span class="line">      position: fixed;</span><br><span class="line">      top: 0;</span><br><span class="line">      right:0;</span><br><span class="line">      width: 200px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      background: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .menu ul&#123;</span><br><span class="line">      display: flex;</span><br><span class="line">      flex-direction: column;</span><br><span class="line">      background: #aaa;</span><br><span class="line">      height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .menu ul li&#123;</span><br><span class="line">      flex-grow: 1;</span><br><span class="line">      text-align: center;</span><br><span class="line">      display: flex;</span><br><span class="line">      align-items: center;</span><br><span class="line">      justify-content: center;</span><br><span class="line">      background:#ccc;</span><br><span class="line">      color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    a&#123;</span><br><span class="line">      text-decoration: none;</span><br><span class="line">      color: inherit;</span><br><span class="line">    &#125;</span><br><span class="line">    .menu ul li.active a&#123;</span><br><span class="line">      color: red;</span><br><span class="line">      font-weight: 900;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot; id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">      &lt;ul v-if=&quot;ary.length&quot;&gt;</span><br><span class="line">        &lt;li v-for=&quot;(item,idx) of ary&quot; :class=&quot;`$&#123;item&#125;`&quot;&gt;</span><br><span class="line">          &lt;a :href=&quot;`#$&#123;item&#125;`&quot;&gt; &#123;&#123;item&#125;&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div title1&quot; id=&quot;title1&quot; &gt;</span><br><span class="line">      &lt;h1&gt;title1&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Odio aspernatur iure esse vero eveniet quam, laudantium optio facere voluptate, autem ratione nihil dolorem veritatis non unde repellendus in maiores explicabo suscipit. Omnis quisquam tempora eum doloribus repellendus deserunt architecto, corrupti est, odit accusamus repellat ipsa voluptas quis nesciunt. Quos nostrum dolor, ratione, facere quis quibusdam nemo, vitae temporibus delectus voluptate odit eius debitis earum atque minus suscipit reiciendis. Perspiciatis cupiditate corporis nam dolore tempore molestias exercitationem nesciunt optio provident fugiat suscipit libero earum ea, modi nulla, quas delectus veniam, doloremque necessitatibus inventore. Ratione mollitia sequi architecto labore dolores magni omnis tenetur provident. Debitis praesentium tempora sit rerum! Eaque eum, sunt nesciunt voluptatem magni, nihil impedit dolorum nostrum assumenda eos at corrupti velit nam omnis quaerat esse iste dolorem? Exercitationem accusantium sint harum, ab nesciunt alias velit eveniet soluta sequi, nulla, facilis aliquid expedita modi possimus sit. Explicabo eveniet voluptates quis amet voluptas deleniti dolor, nostrum fugit error labore omnis exercitationem iste impedit saepe tempore nulla earum sequi aspernatur ratione harum! Magni autem quam magnam alias fuga nemo, quibusdam aliquid? Maxime adipisci eligendi eius ab repellat, iste aliquid illo provident similique obcaecati fuga animi quibusdam, quidem in numquam molestiae minus mollitia sequi veniam placeat molestias voluptates ex totam! Maiores veritatis cumque doloribus quas dolores illo facere deleniti in, perferendis, ea, facilis porro. Dignissimos vitae, nesciunt velit nostrum iste iure labore tempore consectetur ducimus exercitationem recusandae voluptas blanditiis ut aut, accusamus pariatur voluptates rerum consequatur qui assumenda vel provident neque? Delectus reiciendis incidunt molestiae iusto ea officia itaque ipsum at doloremque hic dolorem eius atque sunt, corporis, magni deleniti sint odit optio fuga. Ratione expedita eligendi magni voluptate alias delectus totam tempora veritatis, qui itaque? Tenetur ea quam quisquam deleniti itaque asperiores nesciunt, culpa nam dolorum voluptate amet ducimus exercitationem laborum, temporibus optio! Minima reprehenderit ipsum sit quisquam, ipsam est voluptates recusandae adipisci, a voluptas perspiciatis officiis, quibusdam eos? Dicta facere modi voluptatem inventore? Odit a repellendus corrupti atque porro nostrum perferendis possimus, repudiandae quas incidunt enim maiores ea distinctio ad est quaerat. Explicabo suscipit laborum, ea amet in id quis consequatur odio quo perferendis nihil quia necessitatibus nostrum quam vero laudantium iusto tempora voluptate nulla. Corrupti perferendis culpa, similique praesentium saepe sint porro! Vero unde illum tempore dolore, eaque saepe voluptate repellat similique commodi eos doloremque nulla quos itaque tenetur enim, error culpa fuga quisquam laborum? Earum, corporis, libero quo voluptatibus voluptatem odio dignissimos aliquid nam ea esse vel eveniet, similique recusandae. Nesciunt quasi tenetur aperiam laboriosam consectetur aut quae soluta reprehenderit deserunt, dolore ratione ipsum fugiat! Accusamus a vel delectus repellat laudantium dignissimos reprehenderit eveniet, ipsum dolorem placeat labore tenetur accusantium tempora beatae aperiam commodi eligendi inventore velit. Esse repellendus deleniti rerum praesentium! Soluta ipsam dolore quod suscipit corrupti cum doloribus iure voluptatem alias accusamus molestias maiores sint excepturi magni magnam labore, accusantium adipisci aspernatur, quidem dolores perspiciatis saepe repellendus rem? Repudiandae, maiores culpa sequi voluptates distinctio quae explicabo mollitia ea repellat, cum ipsam adipisci aliquam accusantium perferendis nobis beatae.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quidem eveniet architecto rerum amet corrupti velit tempore odit placeat, impedit, nisi eligendi? At excepturi reiciendis ab tempore voluptas voluptatum aperiam nisi.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div title2&quot; id=&quot;title2&quot;&gt;</span><br><span class="line">      &lt;h1&gt;title2&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Odio aspernatur iure esse vero eveniet quam, laudantium optio facere voluptate, autem ratione nihil dolorem veritatis non unde repellendus in maiores explicabo suscipit. Omnis quisquam tempora eum doloribus repellendus deserunt architecto, corrupti est, odit accusamus repellat ipsa voluptas quis nesciunt. Quos nostrum dolor, ratione, facere quis quibusdam nemo, vitae temporibus delectus voluptate odit eius debitis earum atque minus suscipit reiciendis. Perspiciatis cupiditate corporis nam dolore tempore molestias exercitationem nesciunt optio provident fugiat suscipit libero earum ea, modi nulla, quas delectus veniam, doloremque necessitatibus inventore. Ratione mollitia sequi architecto labore dolores magni omnis tenetur provident. Debitis praesentium tempora sit rerum! Eaque eum, sunt nesciunt voluptatem magni, nihil impedit dolorum nostrum assumenda eos at corrupti velit nam omnis quaerat esse iste dolorem? Exercitationem accusantium sint harum, ab nesciunt alias velit eveniet soluta sequi, nulla, facilis aliquid expedita modi possimus sit. Explicabo eveniet voluptates quis amet voluptas deleniti dolor, nostrum fugit error labore omnis exercitationem iste impedit saepe tempore nulla earum sequi aspernatur ratione harum! Magni autem quam magnam alias fuga nemo, quibusdam aliquid? Maxime adipisci eligendi eius ab repellat, iste aliquid illo provident similique obcaecati fuga animi quibusdam, quidem in numquam molestiae minus mollitia sequi veniam placeat molestias voluptates ex totam! Maiores veritatis cumque doloribus quas dolores illo facere deleniti in, perferendis, ea, facilis porro. Dignissimos vitae, nesciunt velit nostrum iste iure labore tempore consectetur ducimus exercitationem recusandae voluptas blanditiis ut aut, accusamus pariatur voluptates rerum consequatur qui assumenda vel provident neque? Delectus reiciendis incidunt molestiae iusto ea officia itaque ipsum at doloremque hic dolorem eius atque sunt, corporis, magni deleniti sint odit optio fuga. Ratione expedita eligendi magni voluptate alias delectus totam tempora veritatis, qui itaque? Tenetur ea quam quisquam deleniti itaque asperiores nesciunt, culpa nam dolorum voluptate amet ducimus exercitationem laborum, temporibus optio! Minima reprehenderit ipsum sit quisquam, ipsam est voluptates recusandae adipisci, a voluptas perspiciatis officiis, quibusdam eos? Dicta facere modi voluptatem inventore? Odit a repellendus corrupti atque porro nostrum perferendis possimus, repudiandae quas incidunt enim maiores ea distinctio ad est quaerat. Explicabo suscipit laborum, ea amet in id quis consequatur odio quo perferendis nihil quia necessitatibus nostrum quam vero laudantium iusto tempora voluptate nulla. Corrupti perferendis culpa, similique praesentium saepe sint porro! Vero unde illum tempore dolore, eaque saepe voluptate repellat similique commodi eos doloremque nulla quos itaque tenetur enim, error culpa fuga quisquam laborum? Earum, corporis, libero quo voluptatibus voluptatem odio dignissimos aliquid nam ea esse vel eveniet, similique recusandae. Nesciunt quasi tenetur aperiam laboriosam consectetur aut quae soluta reprehenderit deserunt, dolore ratione ipsum fugiat! Accusamus a vel delectus repellat laudantium dignissimos reprehenderit eveniet, ipsum dolorem placeat labore tenetur accusantium tempora beatae aperiam commodi eligendi inventore velit. Esse repellendus deleniti rerum praesentium! Soluta ipsam dolore quod suscipit corrupti cum doloribus iure voluptatem alias accusamus molestias maiores sint excepturi magni magnam labore, accusantium adipisci aspernatur, quidem dolores perspiciatis saepe repellendus rem? Repudiandae, maiores culpa sequi voluptates distinctio quae explicabo mollitia ea repellat, cum ipsam adipisci aliquam accusantium perferendis nobis beatae.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quidem eveniet architecto rerum amet corrupti velit tempore odit placeat, impedit, nisi eligendi? At excepturi reiciendis ab tempore voluptas voluptatum aperiam nisi.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div title3&quot; id=&quot;title3&quot; &gt;</span><br><span class="line">      &lt;h1&gt;title3&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Aut nemo inventore quaerat consequuntur culpa qui accusantium explicabo quod voluptatum ab, quidem rem ipsa? Tempora, pariatur vitae neque voluptatum eum sed iusto maiores fugiat repellendus incidunt iste explicabo obcaecati eveniet quibusdam non a sint voluptas, illum vero exercitationem sunt nihil voluptate? Hic, quo nesciunt. Vel exercitationem ipsam error eligendi nisi voluptate earum nesciunt ullam fuga. Ipsum exercitationem culpa, laborum repellat nulla iusto vitae rerum eligendi. Fugit sunt, tenetur itaque reiciendis non magnam officiis odit voluptatum culpa fuga, velit ab! Quaerat totam sapiente laborum quae eius tempora obcaecati qui aliquid animi. Expedita adipisci aperiam deleniti deserunt repudiandae velit ipsa temporibus dolorum minus? Inventore, quo dolorem possimus reiciendis repellendus veniam praesentium provident ratione eos officia corrupti architecto, sequi cum at obcaecati fuga repudiandae? Necessitatibus, veritatis recusandae hic eos ducimus cumque tenetur odio, doloribus sapiente quam similique tempora at voluptate nesciunt quisquam dolore sit saepe molestias dolores illum placeat sunt. Eos, doloribus? Soluta explicabo similique vitae tempore blanditiis voluptatem dicta? Eius repellendus id sit accusamus saepe rem debitis modi vel dolores autem ut voluptatum a sequi aliquam, ad eos eum libero iure minus quam sint. Necessitatibus eum id commodi quae? Incidunt rem atque dolores eligendi voluptatibus aliquam aspernatur numquam. Nobis, iusto illo! Repellendus, a sapiente vitae voluptatum iusto corporis perspiciatis earum cupiditate optio, blanditiis est voluptates ducimus inventore ullam amet id minus neque sit harum corrupti aspernatur. Commodi mollitia aperiam aspernatur magni, aliquam quas quia voluptas accusantium repellendus obcaecati cumque quibusdam voluptatem labore ab non eum rem! Nostrum, accusantium delectus rerum explicabo ipsa obcaecati nobis commodi animi est repellendus culpa eos eum aliquam sit quod nesciunt maxime excepturi ducimus deserunt! Eligendi, nostrum. Iste repudiandae incidunt corrupti atque. Nemo impedit porro mollitia corrupti aut nihil repellendus quibusdam libero. Numquam explicabo veritatis libero aut ex aliquam consequatur adipisci sint vitae architecto velit quidem iste saepe consequuntur quisquam cum, magnam deleniti amet sed error facilis vero magni alias. Sit, minus provident quia harum iure officia porro nemo doloremque voluptatum. Culpa laudantium consectetur fuga, temporibus iste ipsa accusantium pariatur molestias harum! Ullam dignissimos corrupti ipsam vero reiciendis iure dicta sed aliquid officia eos adipisci soluta quibusdam in deleniti similique aperiam deserunt, quis provident itaque quia sint? Vel odit sit, quasi molestiae quaerat unde nihil maxime harum, doloribus libero assumenda, facere illo corrupti. Error dicta repellat, rerum ratione atque, impedit quia nobis nisi ipsa veniam dolore minus porro libero eos fugiat laudantium at perspiciatis architecto! Sunt modi, optio nulla dignissimos in provident repudiandae libero. Voluptatibus tempora consequuntur alias necessitatibus quisquam culpa porro sequi, odio quam voluptates commodi deleniti impedit fuga, corporis explicabo totam minima ad eligendi ipsa laborum exercitationem dolorem libero aliquam. Quibusdam natus nulla facere saepe! Sunt, eius voluptatum. Placeat, neque exercitationem commodi nulla quis cum facere recusandae ipsa esse ad accusamus distinctio, officia, odio aperiam. Suscipit velit aliquam officia iure, non rerum numquam laborum error quas neque enim cum illum accusantium facilis tempora, eum ipsam porro quidem similique, recusandae unde illo culpa nisi. Pariatur, voluptates? Sapiente, nam?&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Odio aspernatur iure esse vero eveniet quam, laudantium optio facere voluptate, autem ratione nihil dolorem veritatis non unde repellendus in maiores explicabo suscipit. Omnis quisquam tempora eum doloribus repellendus deserunt architecto, corrupti est, odit accusamus repellat ipsa voluptas quis nesciunt. Quos nostrum dolor, ratione, facere quis quibusdam nemo, vitae temporibus delectus voluptate odit eius debitis earum atque minus suscipit reiciendis. Perspiciatis cupiditate corporis nam dolore tempore molestias exercitationem nesciunt optio provident fugiat suscipit libero earum ea, modi nulla, quas delectus veniam, doloremque necessitatibus inventore. Ratione mollitia sequi architecto labore dolores magni omnis tenetur provident. Debitis praesentium tempora sit rerum! Eaque eum, sunt nesciunt voluptatem magni, nihil impedit dolorum nostrum assumenda eos at corrupti velit nam omnis quaerat esse iste dolorem? Exercitationem accusantium sint harum, ab nesciunt alias velit eveniet soluta sequi, nulla, facilis aliquid expedita modi possimus sit. Explicabo eveniet voluptates quis amet voluptas deleniti dolor, nostrum fugit error labore omnis exercitationem iste impedit saepe tempore nulla earum sequi aspernatur ratione harum! Magni autem quam magnam alias fuga nemo, quibusdam aliquid? Maxime adipisci eligendi eius ab repellat, iste aliquid illo provident similique obcaecati fuga animi quibusdam, quidem in numquam molestiae minus mollitia sequi veniam placeat molestias voluptates ex totam! Maiores veritatis cumque doloribus quas dolores illo facere deleniti in, perferendis, ea, facilis porro. Dignissimos vitae, nesciunt velit nostrum iste iure labore tempore consectetur ducimus exercitationem recusandae voluptas blanditiis ut aut, accusamus pariatur voluptates rerum consequatur qui assumenda vel provident neque? Delectus reiciendis incidunt molestiae iusto ea officia itaque ipsum at doloremque hic dolorem eius atque sunt, corporis, magni deleniti sint odit optio fuga. Ratione expedita eligendi magni voluptate alias delectus totam tempora veritatis, qui itaque? Tenetur ea quam quisquam deleniti itaque asperiores nesciunt, culpa nam dolorum voluptate amet ducimus exercitationem laborum, temporibus optio! Minima reprehenderit ipsum sit quisquam, ipsam est voluptates recusandae adipisci, a voluptas perspiciatis officiis, quibusdam eos? Dicta facere modi voluptatem inventore? Odit a repellendus corrupti atque porro nostrum perferendis possimus, repudiandae quas incidunt enim maiores ea distinctio ad est quaerat. Explicabo suscipit laborum, ea amet in id quis consequatur odio quo perferendis nihil quia necessitatibus nostrum quam vero laudantium iusto tempora voluptate nulla. Corrupti perferendis culpa, similique praesentium saepe sint porro! Vero unde illum tempore dolore, eaque saepe voluptate repellat similique commodi eos doloremque nulla quos itaque tenetur enim, error culpa fuga quisquam laborum? Earum, corporis, libero quo voluptatibus voluptatem odio dignissimos aliquid nam ea esse vel eveniet, similique recusandae. Nesciunt quasi tenetur aperiam laboriosam consectetur aut quae soluta reprehenderit deserunt, dolore ratione ipsum fugiat! Accusamus a vel delectus repellat laudantium dignissimos reprehenderit eveniet, ipsum dolorem placeat labore tenetur accusantium tempora beatae aperiam commodi eligendi inventore velit. Esse repellendus deleniti rerum praesentium! Soluta ipsam dolore quod suscipit corrupti cum doloribus iure voluptatem alias accusamus molestias maiores sint excepturi magni magnam labore, accusantium adipisci aspernatur, quidem dolores perspiciatis saepe repellendus rem? Repudiandae, maiores culpa sequi voluptates distinctio quae explicabo mollitia ea repellat, cum ipsam adipisci aliquam accusantium perferendis nobis beatae.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quidem eveniet architecto rerum amet corrupti velit tempore odit placeat, impedit, nisi eligendi? At excepturi reiciendis ab tempore voluptas voluptatum aperiam nisi.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const &#123; createApp &#125; = Vue</span><br><span class="line"></span><br><span class="line">    createApp(&#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          ary:[]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mounted() &#123;</span><br><span class="line">        let h1Ary = [...document.querySelectorAll(&#x27;h1&#x27;)].map((d)=&gt;d.innerText)</span><br><span class="line">        this.ary = h1Ary;</span><br><span class="line"></span><br><span class="line">        const observerOptions = &#123;</span><br><span class="line">          root: null,</span><br><span class="line">          rootMargin: &quot;0px&quot;,</span><br><span class="line">          threshold: [0.0, 0.75]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        adObserver = new IntersectionObserver(intersectionCallback,</span><br><span class="line">                          observerOptions);</span><br><span class="line"></span><br><span class="line">        function intersectionCallback(entries) &#123;</span><br><span class="line">          entries.forEach((entry) =&gt; &#123;</span><br><span class="line">            let e = entry.target.classList[1]</span><br><span class="line">            let li = document.querySelector(`li.$&#123;e&#125;`)</span><br><span class="line">            if (entry.isIntersecting) &#123;</span><br><span class="line">              if (entry.intersectionRatio &gt;=0.75) &#123;</span><br><span class="line">                li.classList.add(&#x27;active&#x27;)</span><br><span class="line">                li.querySelector(&#x27;a&#x27;).click()</span><br><span class="line">              &#125;else&#123;</span><br><span class="line">                li.classList.remove(&#x27;active&#x27;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">        h1Ary.forEach((d)=&gt;&#123;</span><br><span class="line">          let x= document.querySelector(`div.$&#123;d&#125;`)</span><br><span class="line">          adObserver.observe(x)</span><br><span class="line">        &#125;)</span><br><span class="line">        &#125;,500)</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;).mount(&#x27;#app&#x27;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>參考資料<br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" >MDN Intersection Observer<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Intersection Observer API</tag>
      </tags>
  </entry>
  <entry>
    <title>如何操作複雜的物件結構</title>
    <url>/frontend-004/</url>
    <content><![CDATA[<h1 id="如何操作複雜的物件結構"><a href="#如何操作複雜的物件結構" class="headerlink" title="如何操作複雜的物件結構"></a>如何操作複雜的物件結構</h1><p>在開發過程中，前端工程師們常常會遇到許多複雜的資料結構，結構與頁面的抽象及邏輯成正比，簡單來說，越複雜的結構就反應越複雜的頁面邏輯，當我們看到這些結構可以做哪些方法，去優化、簡化這些結構，來增加我們的開發效率並降低心智負擔呢?畢竟看到層層疊疊的物件及陣列，相信正常人的頭都會隱隱作痛XD<br>下面我們就來依序介紹:</p>
<blockquote>
<p>1.處理方法(Api工具)<br>2.邏輯拆解(思考資料結構拆分)<br>3.組合及優化(解題)</p>
</blockquote>
<h2 id="處理方法"><a href="#處理方法" class="headerlink" title="處理方法"></a>處理方法</h2><p>通常複雜的資料結構不免俗的就是物件及陣列的巢狀嵌套，要先來了解有哪些方法可以幫助我們處理，並用方法把目標解構出來吧!!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---條件篩選 </span><br><span class="line"><span class="keyword">const</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">const</span> aryMap=[&#123;<span class="attr">name</span>:<span class="string">&#x27;allen&#x27;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;joy&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>filter 遍歷目標陣列篩選出符合條件的物件，並回傳陣列。</span><br><span class="line"></span><br><span class="line">ary.<span class="title function_">filter</span>(<span class="function">(<span class="params">num</span>)=&gt;</span>num&gt;<span class="number">3</span>) =&gt; [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>find  遍歷目標陣列篩選出符合條件的物件，並回傳物件。</span><br><span class="line"></span><br><span class="line">aryMap.<span class="title function_">find</span>(<span class="function">(<span class="params">d</span>)=&gt;</span>d.<span class="property">name</span>===<span class="string">&#x27;allen&#x27;</span>) =&gt; &#123;<span class="attr">name</span>: <span class="string">&#x27;allen&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>findIndex 遍歷目標陣列篩選出符合條件的物件，並回傳目標索引。</span><br><span class="line"></span><br><span class="line">ary.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">num</span>)=&gt;</span>num&gt;<span class="number">3</span>) =&gt; <span class="number">3</span> (找到目標後,就停止遍歷。)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>includes 遍歷目標陣列篩選出符合條件的物件，並回傳布林值。</span><br><span class="line"></span><br><span class="line">aryMap.<span class="title function_">includes</span>(<span class="function">(<span class="params">d</span>)=&gt;</span> d.<span class="property">name</span> === <span class="string">&#x27;jack&#x27;</span>) =&gt; <span class="literal">false</span> </span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>indexOf  回傳目標陣列中第一個被找到的索引值，若不存在則會回傳-<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">ary.<span class="title function_">indexOf</span>(<span class="number">3</span>)  =&gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">---資料重組</span><br><span class="line"><span class="number">1.</span>map 遍歷陣列依照設定格式，回傳陣列。</span><br><span class="line"></span><br><span class="line">ary.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>)=&gt;</span>(&#123;<span class="attr">num</span>:x&#125;)) =&gt;[&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">num</span>:<span class="number">2</span>&#125;...]</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>reduce 遍歷陣列依照閉包設定格式，回傳陣列、或物件。(非常重要,可以組出任意元素)</span><br><span class="line">ary.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">  acc[cur] = <span class="string">&#x27;id&#x27;</span>+cur+<span class="string">&#x27;!&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> acc</span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line"></span><br><span class="line">=&gt;&#123;<span class="number">1</span>: <span class="string">&#x27;id1!&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;id2!&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;id3!&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;id4!&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;id5!&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上的方法，有些是以閉包模式傳遞，並在內部遞迴後回傳出來，相當地有趣，筆者會在最後附上相關的實現內容，有興趣的話可以自己實做看看!會對這些方法的操作更加的熟悉!</p>
<p>不知道有沒有一個疑問，那就是上方都是陣列的方法，那物件呢?陣列的原型方法沒法使用阿!?<br>物件原型方法上的篩選methods的確很少XD，但我們可以把物件轉成陣列模式操作啊!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>:<span class="string">&#x27;123&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;234&#x27;</span>,<span class="attr">c</span>:<span class="string">&#x27;345&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">keys</span> 回傳物件key值陣列</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj) =&gt;  [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">values</span> 回傳物件value值陣列</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj) =&gt;[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;234&#x27;</span>, <span class="string">&#x27;345&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到這個模式是否燃燒起你的小宇宙了呢!!我們來合體操作看看吧!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;<span class="number">1</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;allen&#x27;</span>&#125;,<span class="number">2</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;joke&#x27;</span>&#125;,<span class="number">3</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;mindy&#x27;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj2).<span class="title function_">filter</span>(<span class="function">(<span class="params">d</span>)=&gt;</span>d.<span class="property">name</span>===<span class="string">&#x27;mindy&#x27;</span>) =&gt; &#123;<span class="attr">name</span>: <span class="string">&#x27;mindy&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="邏輯拆解"><a href="#邏輯拆解" class="headerlink" title="邏輯拆解"></a>邏輯拆解</h2><p>找出我們所需的關鍵資料的一個想法或概念,我們可以透過畫出flow，去嘗試構思哪些資料是我們所需的，且在解題時為必要，<br>透過這些拆分，我們可以把複雜的資料給拆解出細小原子，在不斷的組合起來。</p>
<h2 id="解題"><a href="#解題" class="headerlink" title="解題"></a>解題</h2><p>在熟悉這些組合操作後，我們來挑戰一題較為困難的題目吧!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memberList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">member</span>: <span class="string">&quot;Alex&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">85</span>,</span><br><span class="line">    <span class="attr">order</span>: [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;E&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">member</span>: <span class="string">&quot;jabo&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">83</span>,</span><br><span class="line">    <span class="attr">order</span>: [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">member</span>: <span class="string">&quot;allen&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">order</span>: [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">member</span>: <span class="string">&quot;phobe&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">90</span>,</span><br><span class="line">    <span class="attr">order</span>: [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">member</span>: <span class="string">&quot;celia&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="attr">order</span>: [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">Ｑ：按照分數高低，最後導出使用者的希望組別，組別不可以重複</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">memberList.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;a.<span class="property">score</span>-b.<span class="property">score</span>&#125;) <span class="comment">//先照高分順序排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照 組別分組</span></span><br><span class="line"><span class="keyword">let</span> groupBox = memberList.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur, i</span>) =&gt;</span> &#123;</span><br><span class="line">  i === <span class="number">0</span> &amp;&amp; cur.<span class="property">order</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">d</span>) =&gt;</span> (acc[d] = [])); <span class="comment">//先將組別放入物件中，並將值設為陣列</span></span><br><span class="line">  cur.<span class="property">order</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">d, x</span>) =&gt;</span> &#123;</span><br><span class="line">    acc[d].<span class="title function_">push</span>(&#123; d, <span class="attr">n</span>: cur.<span class="property">member</span>, <span class="attr">s</span>: cur.<span class="property">score</span>, <span class="attr">hopeIndex</span>: x &#125;); <span class="comment">//依照順序送入陣列中</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = [];</span><br><span class="line"><span class="keyword">let</span> pointer = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//指針移動推入希望組別</span></span><br><span class="line"><span class="keyword">while</span> (pointer &lt; memberList.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> groupBox) &#123;</span><br><span class="line">    map.<span class="title function_">push</span>(groupBox[key][pointer]); <span class="comment">//此時的map陣列中就是按照分數高低及使用者意願的順序</span></span><br><span class="line">    pointer++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">但這解法有一個問題，就是<span class="keyword">for</span> <span class="keyword">in</span> 並保證key順序，若為重要資料陣列，建議還是另外保存索引值，較為理想喔!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有更有趣的實現方式，歡迎在下方留言~</p>
<p><a class="link"   href="https://github.com/eepson123tw/DeepLearnJs/blob/master/10%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%AF%A6%E7%8F%BE/arrayApi.js" >陣列實現<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/for...in" >for in<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ArrayMethods</tag>
        <tag>iterable Obj</tag>
      </tags>
  </entry>
  <entry>
    <title>網頁的效能指標及優化</title>
    <url>/frontend-005/</url>
    <content><![CDATA[<h1 id="知道網頁有哪些效能指標嗎"><a href="#知道網頁有哪些效能指標嗎" class="headerlink" title="知道網頁有哪些效能指標嗎?"></a>知道網頁有哪些效能指標嗎?</h1><p>常常聽到網頁開發撰寫功能時，需要顧及效能及優化網頁效率等用詞，但我們真的知道如何去改善這些指標嗎?更進一步的說我們知道指標到底有那些嗎?<br>這些指標又各自代表著甚麼意義，需要我們如何調校呢?接下來我們一一的介紹並分析這些指標吧~</p>
<h2 id="效能對使用者來說"><a href="#效能對使用者來說" class="headerlink" title="效能對使用者來說?"></a>效能對使用者來說?</h2><p>對使用者來說，網站的優劣，其實也不難分辨，就是網站載入的速度，使用上的流程體感是否順暢，頁面功能都能正常使用，畫面不會有跑版的情況發生，就已經足夠了。但這些簡單的評估方法，也就包含了許多的效能指標~</p>
<h2 id="First-Contentful-Paint-首次內容加載、繪製時間"><a href="#First-Contentful-Paint-首次內容加載、繪製時間" class="headerlink" title="First Contentful Paint(首次內容加載、繪製時間)"></a>First Contentful Paint(首次內容加載、繪製時間)</h2><p>首次内容繪製 (FCP) 指標即测量頁面從開始加載到頁面内容(包含文本、圖片、canvas等…)的任何部分在視窗上完成渲染的時間，<strong>但並非是所有內容。</strong><br>一個好的網頁FCP應該在1.8內被繪製，換句話說，即是在1.8秒內有任意內容被繪製到網頁上，讓使用者可以看到內容。</p>
<p>FCP可以使用F12的燈塔觀察，或是使用第三方套件測量，js也有提供相關效能api可供檢測，但有些特殊形況，可能會造成差異，需要特別注意。</p>
<blockquote>
<p>優化FCP方法:<br>1.消除阻塞渲染的资源(小心重排與垂繪)<br>2.壓縮 CSS 大小(加載的速度)<br>3.移除未使用的 CSS(tree shaking)<br>4.預連接到所需的来源<br>5.避免巨大的網路負載<br>6.Dom的大小控制<br>7.關鍵請求數的控制(瀏覽器有上限，超過就要等待回傳)</p>
</blockquote>
<hr>
<h2 id="Largest-Contentful-Paint-最大内容繪製、最大視覺元素載入的时間"><a href="#Largest-Contentful-Paint-最大内容繪製、最大視覺元素載入的时間" class="headerlink" title="Largest Contentful Paint 最大内容繪製、最大視覺元素載入的时間"></a>Largest Contentful Paint 最大内容繪製、最大視覺元素載入的时間</h2><p>依據頁面首次開始加載的時間點来報告可視區域内可見的最大圖像或文本內容完成渲染的相對時間。<br>對於SEO来说最重要的指標~! 應在2.5秒内完成最大內容繪製，也就是讓使用者能盡快的看到網頁的重點圖像或文本。<br>載入的時間越快，則越能容易讓使用者留下使用。<strong>注意在加載時，若當前元素被移除，則會重新計算加載時間</strong></p>
<blockquote>
<p>優化LCP方法:<br>1.優化<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path" >關鍵渲染路徑<i class="fas fa-external-link-alt"></i></a>(CSSOM+DOM+布局等)<br>2.優化css(不使用會重新計算的屬性)<br>3.優化圖像(圖像大小控制、暫存等等..)<br>4.優化js(控制js行數，使布局可以更快被運算出來)</p>
</blockquote>
<hr>
<h2 id="First-Input-Delay-首次輸入延遲"><a href="#First-Input-Delay-首次輸入延遲" class="headerlink" title="First Input Delay 首次輸入延遲"></a>First Input Delay 首次輸入延遲</h2><p>計算使用者第一次與網頁互動(點擊連結、點開下拉選單、填表格…etc)時的延遲時間。也就是使用者互動後產生反應的所需時間。<br>良好的輸入延遲應該控制在100毫秒內。主線程的任何處理都有可能影響此數值，需要好好控管，畢竟這代表該網站的第一印象。</p>
<blockquote>
<p>優化FID方法:<br>1.減少第三方代碼的影響<br>2.减少 JavaScript 執行時間<br>3.最小化主線程工作<br>4.保持較低的HTTP請求數和較小的傳輸內容大小</p>
</blockquote>
<hr>
<h2 id="Time-to-Interactive-可交互時間-TTI"><a href="#Time-to-Interactive-可交互時間-TTI" class="headerlink" title="Time to Interactive 可交互時間 (TTI)"></a>Time to Interactive 可交互時間 (TTI)</h2><p>從開始加載到主要子資源完成渲染，並能夠快速、可靠地響應使用者輸入所需的時間。<br>良好的TTI應控制在五秒內，在SSR框架中因為頁面注入的時間較快，常導致頁面出現但功能無法執行的窘境，也是導致使用者耐心下降的原因之一。<br>為了解決這個問題有新的技術出現，例如<a class="link"   href="https://juejin.cn/post/7155300194773860382" >孤島架構<i class="fas fa-external-link-alt"></i></a>，讓核心葉面組件，可以有更快的TTI，並兼顧SEO~</p>
<blockquote>
<p>優化TTI方法:<br>1.減少關鍵請求數量與大小<br>2.減少第三方代碼的影響<br>3.減少js執行時間<br>4.預加載資源</p>
</blockquote>
<hr>
<h2 id="Total-Blocking-Time-總阻塞时间-TBT"><a href="#Total-Blocking-Time-總阻塞时间-TBT" class="headerlink" title="Total Blocking Time 總阻塞时间 (TBT)"></a>Total Blocking Time 總阻塞时间 (TBT)</h2><p>意指FCP到TTI之間，主線程”塞住”的時間加總。也就是阻塞主線程并影響页面可用性的時間長短。<br>若主線程被阻塞超過50毫秒，就有可能會造成使用者的體驗下降。良好的TBT應控制在300毫秒內。</p>
<blockquote>
<p>優化TBT方法:<br>1.減少關鍵請求數量與大小<br>2.減少第三方代碼的影響<br>3.減少js執行時間</p>
</blockquote>
<hr>
<h2 id="Cumulative-Layout-Shift-累積布局偏移-CLS"><a href="#Cumulative-Layout-Shift-累積布局偏移-CLS" class="headerlink" title="Cumulative Layout Shift 累積布局偏移 (CLS)"></a>Cumulative Layout Shift 累積布局偏移 (CLS)</h2><p>衡量頁面點擊某些内容位置發生偏移後对頁面造成的影響，<strong>CLS 為整個頁面生命周期內發生的所有意外布局偏移中最大的布局偏移分數。</strong><br>良好的CLS應控制在0.1以下。只要可視區域中可見元素的起始位置在兩帧之间發生了變更，這样的元素被視为不穩定元素。若要改變起始位置，可以使用transform屬性取代。</p>
<blockquote>
<p>優化CLS方法:<br>1.<strong>始终在您的圖片和視頻元素上包含尺寸属性，或通過使用CSS 長寬比容器之類的方式預留所需的空間。</strong>這種方法可以確保瀏覽器能夠在加載圖片期間在文檔中分配正确的空間大小。請<br>2.<strong>非到必要切勿在現有內容的上方插入内容。</strong>確保發生的任何布局偏移都在預期中。<br>3.多使用transform屬性，而非是那些會觸發<a class="link"   href="https://web.dev/debug-layout-shifts/" >偏移的屬性<i class="fas fa-external-link-alt"></i></a>。</p>
</blockquote>
<hr>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在這些指標中，有幾個共通的重點，例如:請求的數量與大小，第三方套件的影響，布局重排重繪的時間，等等…都是我們開發者必須去注意的!<br>我們可以善用打包工具與框架套件的優勢，去優化這些指標，將這些要點放入我們的日常開發中，這樣網站就會更加可靠~</p>
<p>參考資料:<br><a class="link"   href="https://web.dev/user-centric-performance-metrics/" >google dev<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Performance</tag>
        <tag>Metrics</tag>
      </tags>
  </entry>
  <entry>
    <title>Type與Interface的差異</title>
    <url>/frontend-006/</url>
    <content><![CDATA[<p>最近在學習TypeScript時，覺得Type跟Interface這兩種定義型別的方式，有種若即若離的關係，<br>定義型別何時要用type、何時要用Interface呢?自己也無法解釋的很清楚，於是想把在網路上找到的知識，<br>以及自己的實作做些統整，加深自己的記憶點。</p>
<hr>
<h1 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h1><p>定義型別的一種方法，可採用顯式的定義，也可使用隱式的類型推斷，常用來定義較為簡易的型別類型(較為推薦)，<br>對定義之型別，有較多的操作空間，TypeScript提供了許多工具類型的type供我們使用。可以表示原始類型、聯合類型、元組類型和物件類型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//簡易地定義屬性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Apple</span> = <span class="built_in">string</span> </span><br><span class="line"><span class="comment">//以物件類型定義屬性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Allen</span> =&#123;</span><br><span class="line">  <span class="attr">year</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">kind</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="variable constant_">IQ</span>?:<span class="built_in">number</span>; =&gt;?代表選填</span><br><span class="line">  ():<span class="function"><span class="params">string</span> =&gt;</span> 可以被執行</span><br><span class="line">  [<span class="attr">key</span>:<span class="built_in">string</span>]:<span class="function"><span class="params">any</span> =&gt;</span>可以接受任何 index</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">allen</span>:<span class="built_in">string</span>):<span class="function"><span class="params">string</span> =&gt;</span> 可以被實例化</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">weight</span>:<span class="function"><span class="params">number</span> =&gt;</span>只讀屬性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">s:allen</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( s.<span class="property">IQ</span>,s.<span class="property">year</span>, <span class="title function_">s</span>())</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">s</span>(<span class="string">&#x27;allen&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//工具類型操作 getType </span></span><br><span class="line"> <span class="keyword">type</span> <span class="title class_">GetType</span>&lt;T,K <span class="keyword">extends</span> keyof T&gt; = &#123;[S <span class="keyword">in</span> K]:T[S]&#125;</span><br><span class="line"> <span class="keyword">type</span> c = <span class="title class_">GetType</span>&lt;allen, <span class="string">&#x27;year&#x27;</span>&gt; </span><br><span class="line"> <span class="comment">//type c = &#123;</span></span><br><span class="line"> <span class="comment">//   year: number;</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//工具類型操作 exclude </span></span><br><span class="line"><span class="comment">//利用簡單型別的分配律，去除限制型別，可以把 extends視為限制的關鍵，T 必須符合 K 的條件。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExcludeType</span>&lt;T,K <span class="keyword">extends</span> T&gt; =  T <span class="keyword">extends</span> K ?  <span class="built_in">never</span> : T</span><br><span class="line"><span class="keyword">type</span> a = <span class="title class_">ExcludeType</span>&lt;<span class="string">&#x27;year&#x27;</span> | <span class="string">&#x27;age&#x27;</span> |<span class="string">&#x27;now&#x27;</span>, <span class="string">&#x27;year&#x27;</span>&gt; <span class="comment">// age,now</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去除readOnly屬性 -號可以去除modified修飾詞，預設是+readonly，不用+是因為ts編譯時幫我們加上去了。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Book</span> =&#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">buyYear</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">kind</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">cost</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyRemove</span>&lt;T&gt; = &#123;-<span class="keyword">readonly</span>[S <span class="keyword">in</span> keyof T ]:T[S]&#125;</span><br><span class="line"><span class="keyword">type</span> x = <span class="title class_">ReadonlyRemove</span>&lt;<span class="title class_">Book</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><p>用來形容或描述物件的結構或屬性的型別，也因為Js有許多物件結構的描述，較能用來描述這些預設的js行為~</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> myInterFace&#123;</span><br><span class="line">  [<span class="attr">propname</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">  age?:<span class="built_in">number</span>,  </span><br><span class="line">  <span class="title function_">say</span>():<span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> myInterFace&#123;</span><br><span class="line">  <span class="attr">gender</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:myInterFace = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">12</span>,</span><br><span class="line">  <span class="attr">gender</span>:<span class="string">&#x27;12312313123&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定義class時 可以使用 interface規範 所需的屬性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> <span class="title function_">implements</span>(實現) myInterFace&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 繼承(擴充)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Myclass</span> <span class="keyword">extends</span> myInterFace&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//當然也可以這樣使用</span></span><br><span class="line"><span class="keyword">interface</span> cake&lt;T,K&gt;&#123;</span><br><span class="line">  <span class="attr">cost</span>:T,</span><br><span class="line">  <span class="attr">size</span>:K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:cake&lt;<span class="built_in">number</span>,<span class="built_in">string</span>&gt; =&#123;</span><br><span class="line">  <span class="attr">cost</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="attr">size</span>:<span class="string">&quot;big&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>補充 [key:string|number|symbol] 若建立key必須符合以下型別，不然會ERROR。</strong></p>
<hr>
<h1 id="Type-vs-Interface"><a href="#Type-vs-Interface" class="headerlink" title="Type vs Interface"></a>Type vs Interface</h1><p><strong>與interface的差異在於無法重複覆值，沒有overload特性及merging特性，並且不能繼承實作物件與其屬性。</strong><br>而且語意上也有些需差異，需要多方評估後挑適合的使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Allen</span> = &#123;<span class="attr">year</span>:<span class="built_in">number</span>,<span class="attr">height</span>:<span class="built_in">number</span>&#125; &lt;-顯式定義</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Allen</span> = &#123;<span class="attr">kind</span>:<span class="built_in">string</span>&#125; &lt;- <span class="title class_">Duplicate</span> identifier <span class="string">&#x27;Allen&#x27;</span> 無法合併</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hellen</span> &#123;<span class="attr">year</span>:<span class="built_in">number</span>,<span class="attr">height</span>:<span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hellen</span> &#123;<span class="attr">kind</span>:<span class="built_in">string</span>&#125; &lt;- <span class="title class_">Hellen</span>屬性中有year,height,<span class="function"><span class="params">kind</span> =&gt;</span> merging 合併了</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> cake&#123;</span><br><span class="line">  <span class="attr">cost</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">size</span>:<span class="built_in">number</span>,</span><br><span class="line">  <span class="title function_">match</span>(<span class="attr">s</span>:<span class="built_in">string</span>):<span class="built_in">void</span>; <span class="comment">//overload</span></span><br><span class="line">  <span class="title function_">match</span>(<span class="attr">s</span>:<span class="built_in">number</span>):<span class="built_in">number</span>; <span class="comment">//overload</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">testOne</span> (<span class="attr">a</span>:cake):<span class="built_in">number</span>&#123;</span><br><span class="line"><span class="comment">//  return a.match(&#x27;s&#x27;) // string</span></span><br><span class="line"> <span class="keyword">return</span> a.<span class="title function_">match</span>(<span class="number">18</span>) <span class="comment">//number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如 哪一個更符合座標物件的型別描述呢?</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>簡單下個結論，就是使用前先思考要定義的是原始的型別，亦或是物件型別，若是物件型別是否需要操作其中的屬性，<br>還是單純的表示構造屬性，若需要操作就可以考慮type，反之則可以使用interface做為表示~</p>
<p>若有不同的看法，歡迎在下方留言~</p>
<p><a class="link"   href="https://www.typescriptlang.org/cheatsheets" >TypeScript官網描述<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://basarat.gitbook.io/typescript" >TypeScript DeepDive<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Type</tag>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title>面對複雜的需求時，應該...?</title>
    <url>/frontend-007/</url>
    <content><![CDATA[<p>最近，寫了快大半年的公司系統，終於進入了最後的階段，幾經波折，在開發過程中，也遇到了許多的難點，趁記憶猶新時紀錄下來，統合思考一下，希望下次能少走點彎路。</p>
<h2 id="第一步，確認需求-功能-規模"><a href="#第一步，確認需求-功能-規模" class="headerlink" title="第一步，確認需求(功能)規模"></a>第一步，確認需求(功能)規模</h2><p>由於這是轉換公司後的第一個多人協作的大專案，加上上頭時間給的蠻充裕，沒做太多想法，就草草的開工了，並沒有仔細的確認每個功能的關聯性，<br>開發到後面才發現原來有幾個功能是會互相影響的!!真的是麻煩大了，發現時也已經逼近收尾，真的是自己挖坑給自己跳…<br>應該在收到設計稿時，就要仔細的與設計師確認功能的規模及關連性，免得自己又要開夜車補救及重構QQ</p>
<h2 id="第二步，避免重複造輪子"><a href="#第二步，避免重複造輪子" class="headerlink" title="第二步，避免重複造輪子"></a>第二步，避免重複造輪子</h2><p>由於專案的頁面眾多，且為多人協作的專案，難免有些重複的邏輯功能，例如搜尋、正逆向排序等，常常A與B同事有重複的邏輯，但大家都寫了一遍，<br>後來經過小組會議溝通後，將邏輯抽出共用，這樣若有需要維護並修改時，才不會要維護多個重複的程式片段，省時又省力。</p>
<h2 id="第三步，切頁面刻化邏輯時，多想一些邊緣案例"><a href="#第三步，切頁面刻化邏輯時，多想一些邊緣案例" class="headerlink" title="第三步，切頁面刻化邏輯時，多想一些邊緣案例"></a>第三步，切頁面刻化邏輯時，多想一些邊緣案例</h2><p>由於專案有一個前後版號文本比對的功能，需要由前端建構出相關聯的巢狀邏輯，比對各項欄位是否有變化，且切換文本時，更新的文本內容不能變動，換回當文本時仍需保留暫存，<br>屬於相當複雜的一個大功能，當初在設計架構時，並沒有構思太多異常案例(覺得使用者提出的需求，自己應該清楚如何使用)，但寫的越深入，發現有許多邏輯會互相地衝突，且有些邊緣案例真的是會出現的，使用者體驗並不好，身為一個設計者，真的無法忍受，也是不斷地重構，但若在當初，能由使用者的角度出發，而不是設計者的角度出發，是不是就可以避免一些時間的消耗呢?<br>經歷過這次的經驗，程式寫的快，不如構思的仔細來的好，當然沒有程式是一開始就完美的，但我們應該以更多不同的角度或是投射在不同的角色去解決及思考。</p>
<h2 id="第四步，遇到卡關的地方，也許是真的需要休息一下了"><a href="#第四步，遇到卡關的地方，也許是真的需要休息一下了" class="headerlink" title="第四步，遇到卡關的地方，也許是真的需要休息一下了"></a>第四步，遇到卡關的地方，也許是真的需要休息一下了</h2><p>在開發過程中，真的是遇到許多的關卡，很多思考上的盲點，常常苦思卻還是無法繞出迴路，同事提醒我，不用浪費時間在已經卡住的問題上，明天問題就解決了。<br>一開始並不是很了解這句話的意思，經歷過幾次後，發現其實不是自己不會寫，是腦袋累了跳不出那個迴圈，離開座位走個幾步，回家休息個一晚，過陣子再來看時，就發現了解決問題的方法(佛系coding也是很重要的)。硬想要寫，還是錯的那種感覺，真的是很痛苦XD，或是跟組員討論自己遇到的難點，在討論的過程中，也常常有靈光一閃的解決辦法。</p>
<h2 id="第五步，溝通比甚麼都重要"><a href="#第五步，溝通比甚麼都重要" class="headerlink" title="第五步，溝通比甚麼都重要"></a>第五步，溝通比甚麼都重要</h2><p>有時候想說開發這個東西，應該對使用者體驗有所幫助，但提交給sa檢查時，卻被問說為什麼要多想這個東西呢?這不是與某一部分衝突了嗎?會不會反而造成困擾呢?<br>我才發現多做不一定是好的，應該先與設計師及架構師溝通，這究竟是不是feature，是不是在這個時間點應該實作的功能?還是可以在下一階段再開發呢?<br>多些溝通避免自己白做工，還沒有好果子吃QQ</p>
<h2 id="第六步，不要偷懶，偷要付出的時間"><a href="#第六步，不要偷懶，偷要付出的時間" class="headerlink" title="第六步，不要偷懶，偷要付出的時間"></a>第六步，不要偷懶，偷要付出的時間</h2><p>在開發某部分功能時，擅自的想說這個地方可以省一點邏輯判斷的邏輯，就偷了一層的組件抽象實作，還沾沾自喜的想說，省了兩三天的開發時間，開心得很xd<br>但在一次的會談中，設計師改變了flow的走向，變得需要實作抽象了，真的是欲哭無淚，加上功能及接口都開好了，像是被打了一巴掌般，心裡有種熱辣辣個港覺，真的是不要偷懶，該開的就是要開XD</p>
<h2 id="第七步，重新過濾每個功能及邏輯"><a href="#第七步，重新過濾每個功能及邏輯" class="headerlink" title="第七步，重新過濾每個功能及邏輯"></a>第七步，重新過濾每個功能及邏輯</h2><p>常常隨著開發時間的進行，程式碼庫越長越大，在不經意的情況下會許會使用一些不需要的變數及函式，刪刪減減，有些東西就這樣被遺忘了，但這並不是一個好現象，<br>程式庫應該是要時常回顧及改寫優化的，在每一次的優化及減化下，不論是時間複雜度或是程式碼的decode時間也會有所減少，且對自己的邏輯也會更有把握，透過不斷地重複去精煉自己的思考模式~</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>透過這次的開發，也是對程式開發有了新的認知，多思考多溝通，多方嘗試，不要先預設使用情境，畢竟程式設計師是以另一個視角去開發的，我們很難一次就勾勒出真實的使用情境!<br>不要害怕溝通，說不定會有意想不到的收穫~</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Component</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT 橫空出世，工程師該如何看待這現象?</title>
    <url>/frontend-008/</url>
    <content><![CDATA[<p>最近幾周跟風，與同事一起玩ChatGPT並提問，越用越覺得強大，快速的回復速度加上極高的準確率，讓人不禁感嘆科技的躍進，也看到許多擔心自己會被AI取代的貼文，不禁思考起工程師這個職業真的這麼簡單會被AI取代嗎?</p>
<p>於是做了以下幾點，去分析ChatGPT，並展開這個議題</p>
<ul>
<li>ChatGPT是怎麼演化來的?</li>
<li>龐大的資料究竟怎麼收集?</li>
<li>他到底是使用甚麼模型?基於甚麼模式回答問題?</li>
<li>目前的瓶頸或是限制?</li>
<li>要以甚麼心態去看目前AI的趨勢?</li>
<li>要如何使用這項工具?</li>
</ul>
<h2 id="ChatGPT是怎麼演化來的"><a href="#ChatGPT是怎麼演化來的" class="headerlink" title="ChatGPT是怎麼演化來的?"></a>ChatGPT是怎麼演化來的?</h2><p>ChatGPT 是甚麼呢?</p>
<blockquote>
<p>ChatGPT是一個大型的自然語言(英文、日文、中文)處理模型，由OpenAI(微軟投資公司)開發和訓練。GPT代表”Generative Pre-trained Transformer”，它是一種基於Transformer架構的語言模型，可以根據先前的輸入文本預測下一個可能的文本。ChatGPT是一個特定版本的GPT模型，專門用於對話生成，它可以與人類進行自然而流暢的對話。</p>
</blockquote>
<p>它是為了解決甚麼而誕生的?</p>
<blockquote>
<p>為了解決對話中的自然語言理解、生成和流暢度等問題。基於大量文本數據訓練而成，並經過迭代演進，並非是2023年的新技術。2020年6月時就已經投入商業化，11月30日發佈。屬於AIGC(人工智能技術)的一部分，目前使用AI模型已迭代至GPT-3。</p>
</blockquote>
<p>GPT基於<strong>大規模化</strong>(電腦的硬體提升、龐大的訓練資料1750億筆資料)、<strong>Transformer架構</strong>(自注意力機制的神經網絡架構，用於處理序列數據)、<strong>轉移學習</strong>(將已經學習到的知識、技術、能力，轉移至另外的一個新模型上，並應用)，分析輸入資料並使用<strong>InstructGPT</strong>(新型態的大型語言模型，旨在通過給出明確的指令或提示來生成自然語言文本)，來實現人類的意圖。</p>
<ul>
<li>GPT-1：</li>
</ul>
<p>1.發佈於2018年，是第一個使用Transformer架構的大型通用語言模型。<br>2.以無監督方式在大量文本數據上訓練，能夠生成流暢的自然語言文本。<br>3.使用12個Transformer編碼器層，共計110M個參數。<br>4.在多種自然語言處理任務上取得了良好的表現。<br>5.在發布當時被認為是目前最先進的語言模型之一。</p>
<hr>
<ul>
<li>GPT-2：<br>1.發佈於2019年，是GPT-1的升級版本，增加了模型大小和訓練數據量。<br>2.使用了更多的Transformer編碼器層，共計1.5B個參數，是當時最大的語言模型之一。<br>3.在多種自然語言處理任務上表現優異，能夠生成更長、更複雜、更具有邏輯性的文本。<br>4.因為能夠生成高度可信的假新聞和惡意內容，所以引起了一些擔憂和爭議。<br>5.需要更大的訓練數據和更強的正則化來解決生成有爭議文本的問題。</li>
</ul>
<hr>
<ul>
<li>GPT-3：<br>1.發佈於2020年，是迄今為止最大的通用語言模型，擁有175B個參數。<br>2.使用了更多的Transformer編碼器層和更大的訓練數據，能夠生成更自然、更真實、更多樣化的文本。<br>3.在多種自然語言處理任務上取得了令人驚訝的表現，並且從未見過的應用也出現了。<br>4.能夠快速進行零樣本、一樣本和少樣本學習，並且有能力進行多種語言的翻譯。<br>5.然而，由於巨大的參數量和計算資源需求，GPT-3也面臨著可解釋性、隱私保護和環境影響等問題。</li>
</ul>
<hr>
<p>以上是GPT自行統正出的要點。</p>
<h2 id="龐大的資料究竟怎麼收集"><a href="#龐大的資料究竟怎麼收集" class="headerlink" title="龐大的資料究竟怎麼收集?"></a>龐大的資料究竟怎麼收集?</h2><p>OpenAI 開發了一個自動化的資料擷取程式，可以從各種網站上擷取文字資料，例如維基百科、新聞網站、社群媒體和書籍等等。擷取的資料包括了大量的自然語言文字，例如文章、評論、留言、社交媒體帖子等等。為了確保資料的品質，OpenAI 還使用了多種檢查和篩選機制，例如過濾掉低質量的網站、檢查資料的可信度和準確性等等。GPT-3還使用了多種公開的資料集和語言資源，例如Wikipedia、Common Crawl、BookCorpus等等，這些資料集包含大量的文本資料，可用於訓練模型並進行測試和驗證。</p>
<blockquote>
<p>但仍需 人工標注的指令 和 提示資料集 </p>
</blockquote>
<h2 id="到底是使用甚麼模型-基於甚麼模式回答問題"><a href="#到底是使用甚麼模型-基於甚麼模式回答問題" class="headerlink" title="到底是使用甚麼模型?基於甚麼模式回答問題?"></a>到底是使用甚麼模型?基於甚麼模式回答問題?</h2><p>ChatGPT基於GPT-3模型，無須監督學習，從大量的文本資料中回答詢問問題，透過輸入的資料(提問)與資料(175B參數)算出一個向量參數，也就是算目前的問題與這個資料的距離，若找到最近距離的資料，則有可能是解答，在極大量的資料下，這個距離可以縮短至相當近的距離，即正解。</p>
<blockquote>
<p>可透過使用詞嵌入技術（Word Embedding）來實現，將每個單詞映射到一個高維向量空間中的一個向量，再將這些單詞向量結合起來，得到一個表示整個文本的向量。</p>
</blockquote>
<h2 id="目前的瓶頸或是限制"><a href="#目前的瓶頸或是限制" class="headerlink" title="目前的瓶頸或是限制?"></a>目前的瓶頸或是限制?</h2><p>1.回答的解答是否會違反知識產權?<br>2.回答的解答(來源)究竟是否有經過產出者的合意?<br>3.虛假訊息是否能高效的過濾，要用甚麼技術過濾?有誰能夠背書?<br>4.來源資料庫只到2021年，2022年後的趨勢及知識，無法提出回答。<br>5.專業領域無法保證正確率，使用英文與中文提問，存在偏差。<br>6.若非該領域熟悉者，無法分析此問題是否為該領域正確回答。</p>
<hr>
<blockquote>
<p>若指出錯誤，會馬上道歉，並給出建議，但建議有些是錯誤的(經過程式碼實測，例如請它做出輪播圖，卻有些參數漏了沒有給XD)</p>
</blockquote>
<h2 id="要以甚麼心態去看目前AI的趨勢"><a href="#要以甚麼心態去看目前AI的趨勢" class="headerlink" title="要以甚麼心態去看目前AI的趨勢?"></a>要以甚麼心態去看目前AI的趨勢?</h2><p>不需用悲觀的角度去看目前的趨勢發展，有句俗語說 打不贏就加入，若已形成趨勢，趨勢就不易改變，生為工程師，我們可以觀測這些AI是否可以對我們的工作提出貢獻，對它產出的解答進行優化，加快我們的工作效率。工程師除了要寫程式碼有產出之外，雙向溝通(與User、PM、SA)、時程規劃、通靈(判斷需求是否可行)，都非一朝一夕，AI可以取代的，身為一個技術職位，我們豈能跟新技術保持距離呢?說不定還能用AI寫個專案，發個大財呢~(開玩笑XD)，保持警覺吸取產業新知，並觀察是否有順風車可以搭乘，提升自己的技術力與薪資(出來混還是要討口飯吃的)</p>
<h2 id="要如何使用這項工具"><a href="#要如何使用這項工具" class="headerlink" title="要如何使用這項工具?"></a>要如何使用這項工具?</h2><p>基於觀察及體驗的角度，以下是個人一些提問上的統整。</p>
<p>1.若提問領域英文為主，就盡量用英文提問。<br>2.提問可以層層提問，先由一個基礎問題，再慢慢發展，可以有更全面的認知。<br>3.若是一個廣泛的問題，可以先以問題的核心開始提問。<br>4.若回答相當的大量，可以設定角色回答。(我是一個高中生，請以我能聽懂的程度回答……)<br>5.縮減回答至關鍵要點(統整出簡單要點，10點每點50字內，等等…)<br>6.若是專業問題，可以改為專有名詞回答(使用XXX模型回答，導入某某格式，參考XXX名言等等…)<br>7.可以複製文章請它找出重點並由重點延伸回答。</p>
<hr>
<p>提供幾個好用的英文單句</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Topics about X for the future ⇒ 用於未來式</span><br><span class="line">Please elaborate more on XXX ⇒ 更加細化的分享某領域(展開)</span><br><span class="line">Please recommend some methods or books ⇒ 推薦該領域實際書籍或方法</span><br><span class="line">term project ,portfolio(學習歷程) ⇒ 可以設計出一段時間的學習歷程</span><br><span class="line">Summary 最基礎的摘要</span><br><span class="line">Plot 基本的情節</span><br><span class="line">Detailed synopsis 概要(synopsis)</span><br><span class="line">Quotes 直接抓出最值得參考的</span><br><span class="line">With example 與範例一起顯示 ⇒ discussion questions for XXX with example answers</span><br><span class="line">Table Topics ⇒ 表格話題</span><br><span class="line">similar plots ⇒ 類似情節</span><br></pre></td></tr></table></figure>

<p>若有更好的使用模式，也請提供給我喔~~</p>
<p><a class="link"   href="https://zh.wikipedia.org/zh-tw/OpenAI" >OpenAI wiki<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.slidestalk.com/ai_algorithms/ChatGPT20232023277231656" >ChatGPT研究框架2023<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.entrepreneur.com/science-technology/chatgpt-what-is-it-and-how-does-it-work/445014" >What Is It and How Does It Work?<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://shop.wordup.com.tw/product/1022" >ChatGPT 未來式：從語言學習延伸到日常工作的高效 AI 工具<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Trend</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT機制(JSON Web Tokens)</title>
    <url>/frontend-009/</url>
    <content><![CDATA[<h2 id="什麼是JWT"><a href="#什麼是JWT" class="headerlink" title="什麼是JWT?"></a>什麼是JWT?</h2><p>是一種開放標準Requests for comments(RFC)<a class="link"   href="https://www.rfc-editor.org/rfc/rfc7519" >7519<i class="fas fa-external-link-alt"></i></a>，為了在各種端口安全傳輸JSON。JWT可以被驗證和信任，因為經過數位簽章及金鑰加密的過程(非對稱加密RSA、金鑰雜湊訊息鑑別碼 HMAC、橢圓曲線數位簽章算法 ECDSA)。旨在描述一組token(令牌)，可用於識別當前使用者身分。</p>
<h2 id="對稱加密與不對稱加密"><a href="#對稱加密與不對稱加密" class="headerlink" title="對稱加密與不對稱加密"></a>對稱加密與不對稱加密</h2><p>屬於密碼學(cryptography)的兩種加密方式(安全機制)，防禦來自現實網路世界的攻擊者，都有加密(encryption)與解密(decryption)兩種動作，但實作上有些許的不同。透過密鑰交換讓兩台電腦在密鑰上達到共識(確認收發者的身分)的算法。</p>
<ul>
<li>對稱加密(symmetric encryption):雙方用一樣的密鑰加密和解密，並共享一個密鑰。</li>
<li>不對稱加密(asymmetric encryption):有一組公開密鑰及私有的密鑰，用公鑰加密後，只有有私鑰的人能解密。相反，用私鑰加密後也只有公鑰的擁有者能解密。避免有心人士，還會先行交換公鑰，並在加密數據中加上數位簽章，先用公鑰確認來源數據後，再進行解密。</li>
</ul>
<h2 id="JWT是為了解決甚麼問題-有哪些應用呢"><a href="#JWT是為了解決甚麼問題-有哪些應用呢" class="headerlink" title="JWT是為了解決甚麼問題?有哪些應用呢?"></a>JWT是為了解決甚麼問題?有哪些應用呢?</h2><p>解決了資訊傳遞上及認證使用者身分上的問題，當你登入了一個購物網站，絕對不希望任何有關你的機敏資訊暴露在登入端口上，這時我們的JWT就派上了用場，端口記憶的只會是一組進行過加密的token(內含使用者的身分訊息)，不會有其他多餘訊息，驗證上則會交給後端，確保安全性。加上其回傳的token令牌可以被程式語言解碼(映射)成json物件，此便利性使大多數的開發者願意使用此技術。</p>
<blockquote>
<p>JWT廣泛的被應用在Single Sign On(單點登錄)上，以及網頁的資料交換上。</p>
</blockquote>
<h2 id="JWT的結構"><a href="#JWT的結構" class="headerlink" title="JWT的結構"></a>JWT的結構</h2><p>此令牌(token)由三個結構組成，Header、Payload、Signature，</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure>

<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>通常由兩部分組成：令牌的類型，即 JWT，以及所使用的簽名算法，例如 HMAC SHA256 或 RSA。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後會被 Base64Url 編碼，形成 JWT 的第一部分。</p>
<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>聲明(Claim)內容，有三種:</p>
<ol>
<li>registered 7種訊息建議: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others,</li>
<li>public: 可以由使用 JWT 的人隨意定義。但是為了避免衝突，它們應該在 IANA JSON Web 令牌註冊表中定義，或者定義為包含抗衝突命名空間的 URI。</li>
<li>private claims: 自定義的欄位,可能會是使用者的一些信息描述。</li>
</ol>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後會被 Base64Url 編碼，形成 JWT 的第二部分。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>針對描述的編碼表頭(header)、編碼聲明(payload)、秘密(secret)、表頭中指定的算法，然後對其進行簽名。<br>secret&#x3D;&#x3D;&gt;為伺服器端的密鑰，還記得JWT可以使用非對稱加密方式嗎XD</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br><span class="line"></span><br><span class="line">=&gt; <span class="title function_">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>(hearder).<span class="title function_">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFsbGVuIiwiaWQiOjI3ODUwNjN9</span>(payload).<span class="title class_">NVSX8</span>vVwjcw3oXbOsZv7hp9AzdAAU3gQR8htriPD9sQ(secret)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>合起來就會產生<a class="link"   href="https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFsbGVuIiwiaWQiOjI3ODUwNjN9.NVSX8vVwjcw3oXbOsZv7hp9AzdAAU3gQR8htriPD9sQ" >令牌<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="還有哪些加密概念"><a href="#還有哪些加密概念" class="headerlink" title="還有哪些加密概念?"></a>還有哪些加密概念?</h2><p>硬件加密</p>
<ul>
<li>替換加密:將輸入的文字按照規律替換後輸出。</li>
<li>列移位加密:將輸入的文字按造不規則排列後輸出。</li>
<li>英格瑪加密:替換加密的複雜應用，透過A-&gt;B-&gt;C(但都是不同的替換方式)，每次輸入後，替換方式就會改變，輸出也就不一致。(對稱加密)</li>
</ul>
<p>軟件加密:</p>
<ul>
<li>數據加密標準(1977年) DES (對稱加密)</li>
<li>高級加密標準(2001年) AES 128&#x2F;192&#x2F;256位密鑰 &#x3D;&gt; 把輸入數據切塊每16字節，用替換和移位加密。(重複進行至少10次or以上，在安全性及性能上找到平衡) (對稱加密)</li>
<li>狄菲赫曼密鑰交換(DIFFIE-HELLMAN KEY EXCHANGE) &#x3D;&gt; 模幕運算</li>
<li>RSA(非對稱加密)</li>
</ul>
<h3 id="來源"><a href="#來源" class="headerlink" title="來源"></a>來源</h3><p><a class="link"   href="https://jwt.io/introduction" >JWT<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://medium.com/@RiverChan/%E5%9F%BA%E7%A4%8E%E5%AF%86%E7%A2%BC%E5%AD%B8-%E5%B0%8D%E7%A8%B1%E5%BC%8F%E8%88%87%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86%E6%8A%80%E8%A1%93-de25fd5fa537" >對稱加密與不對稱加密<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zh.wikipedia.org/zh-tw/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" >RSA<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zhuanlan.zhihu.com/p/97953640" >ECDSA<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>FrontendNote</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>簡易函式封裝</title>
    <url>/functional-programming/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/fn/fn1.png"
                      alt="編成範式圖"
                ></p>
<ul>
<li>面向過程 關心執行流程與控制，通過順序執行一組語句來實現一個功能，這些語句的執行過程就是整個程式</li>
<li>物件導向 將數據與指令組織成模塊，模塊間通過繼承、多態、委託等方式實現複用</li>
<li>函數式 核心思想是將運算過程儘量寫成一系列嵌套的函數調用，關注的是做什麼而不是怎麼做</li>
<li>邏輯式 只關心規則、事實和問題的推導這樣的標準方式，不需要關心程序控制，也不需要關心具體的實現算法</li>
</ul>
<hr>
<p>若在網路上搜尋 javascript 的封裝常常會看到物件導向、函數式編成等關鍵字，其核心都是將抽象的細節邏輯去做包裝，優化、細節處理，降低開發複雜度後提供給使用者，我們並不需要了解深度的封裝細節，就能快速地使用這些邏輯，達到我們要的應用。<br>例如現代 js 的三大框架，也是經過許多深度的封裝後，提供開發者便利的 api 及框架環境~</p>
<p>例如:</p>
<ul>
<li>vue2、vue3 -&gt;響應式物件代理(proxy,object.defineproperty)、觀察者、訂閱者、渲染器 。</li>
<li>react 的 render、redux、hook 函式</li>
</ul>
<hr>
<p>今天想介紹最簡單的幾種函數封裝的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">基礎封裝的幾種返回模式</span><br><span class="line">   ()=&gt;() <span class="comment">//返回 function</span></span><br><span class="line">   ()=&gt;&#123;&#125; <span class="comment">//返回帶有方法的 &#123;&#125;</span></span><br><span class="line">   ()=&gt;[] <span class="comment">//返回 陣列</span></span><br><span class="line">   ()=&gt;x?<span class="attr">x</span>:y <span class="comment">//返回 condition</span></span><br><span class="line">   (<span class="keyword">function</span>(<span class="params">root</span>)&#123;&#125;)(<span class="variable language_">window</span>)<span class="comment">//基礎封裝  匿名函數</span></span><br></pre></td></tr></table></figure>

<h2 id="返回-function"><a href="#返回-function" class="headerlink" title="返回 function"></a>返回 function</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">賦值表達式;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m + n;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">10</span>)(<span class="number">20</span>) &gt;&gt; <span class="number">30</span>;</span><br><span class="line">複雜表達式(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="function">(<span class="params">y</span>) =&gt;</span> x + y)(<span class="number">10</span>)(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>我們利用閉包的特性將 m 及 n 分別暫存住各自的值，等到 return 後記憶體便會釋放，我們也能得到 30 最為回傳值。<br>我們也可以利用複雜表達式的寫法去重寫上面的程式碼，兩種寫法是等價的。</p>
<p>有很多應用的情況，例如針對使用者 input 的值，我們需要使用正則的判斷，去檢測有無非預期的輸入，此時就可以使用這種封裝方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">vaild</span> = (<span class="params">rex</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rex.<span class="title function_">test</span>(val);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emailVaild = <span class="title function_">vaild</span>(</span><br><span class="line">  <span class="regexp">/^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/</span></span><br><span class="line">);</span><br><span class="line"><span class="title function_">emailVaild</span>(<span class="string">&quot;aaa@.asdasd&quot;</span>);</span><br><span class="line"><span class="literal">false</span>;</span><br><span class="line"><span class="title function_">emailVaild</span>(<span class="string">&quot;aaa@gmail.com&quot;</span>);</span><br><span class="line"><span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>經過了這一層的封裝，我們就能依照不同的正則規則，去檢驗不同的輸入，非常的方便且複用性相當高。</p>
<h2 id="返回帶有方法的"><a href="#返回帶有方法的" class="headerlink" title="返回帶有方法的{}"></a>返回帶有方法的{}</h2><p>我們封裝一個會回傳物件的函式，讓他再回傳封裝在其中的邏輯，做出一個可以與之互動的錢包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newWaller</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> money = x</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">log</span> = (<span class="params">key</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!log[name]) log[name]=&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(log[name][key]!==<span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    log[name][key] = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">checkMoney</span>:<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(money)&#125;,</span><br><span class="line">    <span class="attr">use</span>:<span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">      money= <span class="title function_">x</span>(money)</span><br><span class="line">      <span class="title function_">log</span>(x.<span class="property">name</span>)  <span class="comment">//傳入fn名稱當作key</span></span><br><span class="line">      <span class="keyword">return</span> money</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">printLog</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(log[name])</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">const</span> allenMoney = <span class="title function_">newWaller</span>(<span class="number">100</span>);</span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">buyDrink</span> = (<span class="params">x</span>) =&gt; x - <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">buylunch</span> = (<span class="params">x</span>) =&gt; x - <span class="number">60</span>;</span><br><span class="line">allenMoney.<span class="title function_">use</span>(buyDrink);</span><br><span class="line">allenMoney.<span class="title function_">use</span>(buylunch);</span><br><span class="line">allenMoney.<span class="title function_">checkMoney</span>();</span><br><span class="line">&gt;<span class="number">30</span></span><br><span class="line">allenMoney.<span class="title function_">printLog</span>();</span><br><span class="line">&gt;&#123;<span class="attr">buyDrink</span>: <span class="string">&#x27;2022/5/7 下午2:24:34&#x27;</span>, <span class="attr">buylunch</span>: <span class="string">&#x27;2022/5/7 下午2:24:34&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="返回-array"><a href="#返回-array" class="headerlink" title="返回 array"></a>返回 array</h2><p>我們可以透過一個封裝過的函式，return 出我們想要的值，更可以透過之前分享的嵌套模式，複合這些邏輯，相當地有趣。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="string">&quot;9&quot;</span>];</span><br><span class="line"><span class="comment">// 封裝 過濾出數字</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNumbers</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      newArr.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getNumbers</span>(arr); <span class="comment">//取得數字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEvenNumber</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      newArr.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getEvenNumber</span>(<span class="title function_">getNumbers</span>(arr)); <span class="comment">//取得偶數</span></span><br></pre></td></tr></table></figure>

<h2 id="返回-condition"><a href="#返回-condition" class="headerlink" title="返回 condition"></a>返回 condition</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tellme</span>(<span class="params">b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b === <span class="literal">true</span> ? <span class="string">&quot;可&quot;</span> : <span class="string">&quot;不可&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">tellme</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNumberEven</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number &gt; <span class="number">0</span> ? (number % <span class="number">2</span> === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">isNumberEven</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">也可以結合之前的應用;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">conditionOne</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;a.name&#125;</span> 比 <span class="subst">$&#123;b.name&#125;</span> 高<span class="subst">$&#123;a.height - b.height&#125;</span>公分，他當兵`</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">conditionTwo</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;b.name&#125;</span> 比 <span class="subst">$&#123;a.name&#125;</span> 高 <span class="subst">$&#123;b.height - a.height&#125;</span>公分，他當兵`</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">beSoldier</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">height</span> &gt; b.<span class="property">height</span> ? <span class="title function_">conditionOne</span>(a, b) : <span class="title function_">conditionTwo</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">beSoldier</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Allen&quot;</span>, <span class="attr">height</span>: <span class="number">180</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;Eric&quot;</span>, <span class="attr">height</span>: <span class="number">170</span> &#125;); <span class="comment">//allen 當兵去囉QQ</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基礎封裝-匿名函數"><a href="#基礎封裝-匿名函數" class="headerlink" title="基礎封裝 匿名函數"></a>基礎封裝 匿名函數</h2><p>這邊就是框架們使用的方式，把一些東西掛載至 window，方便調用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有狀態</span></span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;allen&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> money = <span class="number">87</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x === <span class="string">&quot;you&quot;</span></span><br><span class="line">      ? <span class="string">`Your name is  <span class="subst">$&#123;name&#125;</span> and <span class="subst">$&#123;age&#125;</span> years old.`</span></span><br><span class="line">      : x === <span class="string">&quot;money&quot;</span></span><br><span class="line">      ? <span class="string">`your money is `</span> + money</span><br><span class="line">      : <span class="string">&quot;what?&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getMoney</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`your money is `</span> + money;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setMoney</span>(<span class="params">m</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (money += m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">codingTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>, <span class="number">05</span>) - <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2020</span>, <span class="number">10</span>)) /</span><br><span class="line">        (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) +</span><br><span class="line">      <span class="string">&quot;天&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 將引用保存在外部，一種簡單的對外開放方法的方式</span></span><br><span class="line">  root.<span class="property">Who</span> = &#123; show, getMoney, setMoney, codingTime &#125;;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Who</span>.<span class="title function_">show</span>(<span class="string">&quot;you&quot;</span>);</span><br><span class="line"><span class="title class_">Who</span>.<span class="title function_">show</span>(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="title class_">Who</span>.<span class="title function_">codingTime</span>();</span><br></pre></td></tr></table></figure>

<p>以上介紹的這幾種方式，若經過良好的細節處理及互相應用，你也可以寫出有趣的 lib 供人們使用~</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>function</tag>
        <tag>program</tag>
        <tag>Encapsulation</tag>
      </tags>
  </entry>
  <entry>
    <title>記憶體布局</title>
    <url>/memory-layouts/</url>
    <content><![CDATA[<p>在許多的面試裡，js 的基礎問題是常常會被面試官詢問，像是 Hoisting，var&#x2F;let&#x2F;const 差異，閉包…，而今天想跟各位分享的也是眾多基礎題的其中之一，原型鍊(prototype chain)，要分享原型鍊則需提到 js 記憶體中的布局。<br>在我們尚未執行代碼之前，我們所寫的 JS 以及宿主環境預設的 API 會被存放在「靜態區」，執行時 V8 會按照執行順序將代碼移動到相應的其他區域，而甚麼是宿主的環境呢?常被提到的像是 client 端(browser)、sever 端(node)</p>
<blockquote>
<p>而在 ECMAScript 的規範中沒有對「宿主環境」給出明確的定義。它沒有明確地指出標準輸入和輸出需要確切地在哪個對象中實現，這導致 JS 的內置實現有一定的混亂性。但我們可以客觀地認為： 瀏覽器為 V8 提供基礎的消息循環系統、Global Object、Web API，而 V8 的核心是實現了 ECMAScript 標準定義的一些 Native Object 和一些核心函數 此外 V8 還提供了垃圾回收器、協程功能。</p>
</blockquote>
<p>–引用自業界前輩的分析</p>
<h2 id="記憶體的布局"><a href="#記憶體的布局" class="headerlink" title="記憶體的布局"></a>記憶體的布局</h2><p>JS 的值有兩種類型，基礎值 primitive value 與 引用值 reference value</p>
<ul>
<li>基礎值 Number，String，Boolean，Null，Undefined,Symbol</li>
<li>引用值 Object，function，Array，RegExp，Data，Date</li>
</ul>
<p>常常會在網路上搜尋到 js 是傳值、傳址、傳參考?當我再找資料時，也常常被這些術語搞得十分頭痛。<br>其實我們可以透過簡易圖繪圖畫出記憶體的指向，而不是強記這些術語，反而會十分地清晰。</p>
<p>在畫圖之前，讓我們來想想，以下的程式碼是怎麼被存放在記憶體中的吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;allen&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> e = [];</span><br><span class="line"><span class="keyword">var</span> f = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="記憶體繪圖"><a href="#記憶體繪圖" class="headerlink" title="記憶體繪圖"></a>記憶體繪圖</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="/images/memory_layout/ex1.png"
                      alt="範例1"
                ></p>
<p>在簡易的繪圖中，發現若我們聲明的變量被覆值為基礎值時，記憶體所存的就會是那個值(<strong>其實仍然會是一個地址，因為記憶方便我們先簡化為基礎值本身</strong>)，而引用值則會是以一個地址被記憶體記住。</p>
<hr>
<h2 id="原型鍊"><a href="#原型鍊" class="headerlink" title="原型鍊"></a>原型鍊</h2><p>其實在我們執行程式碼後，會生出一個全域 Global Object，而全域 Global Object 會與宿主環境相關，若我們在 Web 環境中執行，瀏覽器會為我們提供 DOM、BOM、setTimeout、setInterval 巴拉巴拉一大堆的 web api…，而它們都會被掛在 Global Object 中，然後掛到 window 中給我們使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">window</span>).<span class="property">length</span>　</span><br><span class="line">＞＞<span class="number">326</span> 有點肥</span><br></pre></td></tr></table></figure>

<hr>
<p>基於上方的簡易的繪圖我們理解到記憶體的引用值中存放的就是一個地址，那這個地址裡還有甚麼呢?</p>
<h3 id="原型鍊中有兩個重要的屬性"><a href="#原型鍊中有兩個重要的屬性" class="headerlink" title="原型鍊中有兩個重要的屬性"></a>原型鍊中有兩個重要的屬性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">__proto__ 是一個 屬性，值是一個地址</span><br><span class="line">prototype 是一個 object，裡面放公用函數</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e = [];</span><br><span class="line"><span class="keyword">var</span> f = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/memory_layout/ex2.png"
                      alt="範例2"
                ></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e = [];</span><br><span class="line">e.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> f = &#123;&#125;;</span><br><span class="line">f.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line">fn.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>而各自原型物件中也有<strong>proto</strong>存在，陣列原型的 proto 地址會指向物件原型，而物件原型的 proto 地址則指向 null，這大概只能硬記了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="literal">true</span>;</span><br><span class="line"><span class="title function_">dir</span>(<span class="title class_">Object</span>.<span class="property">prototype__proto__</span>);</span><br><span class="line"><span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<p>大致上分享完了，原型鍊簡單來說就引用值的 proto 地址像一條鍊子把原型方法分享給串連起來的樣子。<br>這樣就能理解，為什麼我們聲明變量為引用值時，可以調用那些方法了~</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/memory_layout/sv.gif"
                      alt="範例2"
                ></p>
<p>補充:<br>若在瀏覽器中測試下方程式碼，會發生一個很有趣的事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>person.<strong>proto</strong> 指向 funciton.prototype (如上方解釋)<br>若呼叫，person.prototype 瀏覽器會回傳一個空物件{constructor: ƒ}，<br>會讓人誤以為 person.prototype 會在一開始開出這個物件的記憶體位置，其實不然。<br>需要等到呼叫時才會建立。例如 特地寫 person.prototype 或是 new obj 時產生。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>G/O</tag>
        <tag>prototype chain</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年度回顧</title>
    <url>/review2022/</url>
    <content><![CDATA[<p>主要是想藉由回顧整年度發生的種種歷程，分析自己的學習歷程及評估是否繼續投資時間等等…<br>期望能在回顧的過程中，能獲的新的展望及想法!並規劃明年要達成得目標及展望!!<br>分成 技術學習、人生規劃、理財規劃、閱讀書籍 等大項探討~</p>
<h2 id="技術學習"><a href="#技術學習" class="headerlink" title="技術學習"></a>技術學習</h2><ul>
<li>前端<br>React 18<ul>
<li>F2E 專案練習(檔案上傳及動態 landing page)。</li>
<li>學習 hooks 調用 useState 實作等。</li>
<li>useEffect 與 useLayoutEffect 差異性等新知理解。<br>Vue3</li>
<li>重新再看了一次文件。</li>
<li>reactive ref 等 核心實作理解。<br>Ts</li>
<li>針對聯集、和集等概念，理解集合應用在 ts 上的實作方式。</li>
<li>與 Vue3 專案的實際操作。<br>Tailwind</li>
<li>學習 tailwind 開發模式，並在 F2E 專案中使用。<br>CSS</li>
<li>學習新的屬性，並觀摩實作大量範例(CodePen)。<br>hexo blog</li>
<li>自行架設 blog，並維持每月更新的習慣。</li>
<li>應用 google 的 search console 與 Analytic 分析。<br>Story Book</li>
<li>文件導讀並在小組會議中分享</li>
<li>實作 Vue3+Story Book 的應用組件專案</li>
</ul>
</li>
<li>Devops<br>Docker<ul>
<li>udemy 課程學習</li>
<li>實際在 AMS 中操作 Docker container，並上架前後台應用的網站。<br>Jenkins &#x2F; CI&#x2F;CD</li>
<li>在公司專案中研究並撰寫流水線，修改各階段流程及最佳化部屬應用。</li>
<li>在自己的部落格中也使用gitHub CI&#x2F;CD 達成自動化部屬。</li>
</ul>
</li>
<li>程式碼<ul>
<li>學習函式設計調用並寫出一個diff json插件，並在公司專案上實際應用，比對物件間的差異性。</li>
<li>精煉自己的程式碼邏輯並減少通用宣告</li>
<li>爬了dom相關Api,釐清繼承與原型鏈的瀏覽器關聯，實際查找event api中的區別。</li>
<li>使用函式設計及閉包調用實作Array Api。</li>
<li>理解微任務與宏任務的相關差異，及瀏覽器實作方式。</li>
<li>五種Observer(瀏覽器)的使用方式及差異性</li>
<li>coData的學習及應用</li>
</ul>
</li>
</ul>
<h3 id="技術回顧總結"><a href="#技術回顧總結" class="headerlink" title="技術回顧總結"></a>技術回顧總結</h3><p>一回顧下來，今年也是做了蠻多東西的，還接協助了一個Nuxt3的外部案件，學習到了很多專案經驗，<br>明年會針對Vue3+Ts有更深度的學習，深入理解底層的應用差異，並能更加流利的使用ts。並補足其餘前端知識。<br>明年的後期應會開始接觸後端相關知識。<br>例如:前端安全性、Web3應用技術、3D應用等。要學習的還很多很多，繼續努力!!!!</p>
<h2 id="理財規劃"><a href="#理財規劃" class="headerlink" title="理財規劃"></a>理財規劃</h2><ul>
<li>股市<ul>
<li>尋找優質公司，並觀察總經趨勢操作。</li>
<li>使用均線及相關指標技巧尋找進出點位。</li>
<li>觀察個股趨勢走向，學習技術分析。</li>
<li>觀測三大法人走向</li>
</ul>
</li>
<li>期貨選擇權<ul>
<li>不隨市場起舞，堅定意志。</li>
<li>不隨意進場，直到訊號出現。</li>
</ul>
</li>
<li>經濟指標<ul>
<li>時時觀察相關先行指標變動數據。</li>
<li>觀測是否有重大事件發生、是否有後續影響。</li>
<li>關注美聯儲加息量縮、及數據公布等訊息收集。</li>
</ul>
</li>
</ul>
<h3 id="理財規劃總結"><a href="#理財規劃總結" class="headerlink" title="理財規劃總結"></a>理財規劃總結</h3><p>在今年後段由於室友的推薦，學習了啟富達的財經課程，學習正確的理財投資技巧，並實際進入股市及期貨學習操作方式，<br>幾經浮沉，目前仍是小賠的階段XD，但也從中學到了如何正確操作及分析的方法，期許明年投資標的可以獲利，並訓練市場靈敏度!</p>
<h2 id="閱讀書籍"><a href="#閱讀書籍" class="headerlink" title="閱讀書籍"></a>閱讀書籍</h2><ul>
<li>經濟<ul>
<li>經濟指標教你加減碼</li>
<li>投資金律</li>
</ul>
</li>
<li>技術<ul>
<li>程式資料密集應用</li>
<li>SQL經典實例</li>
<li>Javascript 高級程序設計</li>
<li>Vue.js 的設計與實踐</li>
</ul>
</li>
<li>成長學習<ul>
<li>代碼之外的生存指南</li>
<li>底層邏輯</li>
<li>人性的弱點</li>
<li>原子習慣</li>
<li>破框能力</li>
</ul>
</li>
</ul>
<h3 id="閱讀書籍總結"><a href="#閱讀書籍總結" class="headerlink" title="閱讀書籍總結"></a>閱讀書籍總結</h3><p>明年會繼續維持閱讀習慣，找到值得學習的好書!書籍目標會往程式碼架構、測試等搜尋，心靈成長及如何與自己獨處等書籍也是目標之一，<br>還有與金錢相關的理財概念，也是值得投資時間的好夥伴!</p>
<h2 id="人生規劃"><a href="#人生規劃" class="headerlink" title="人生規劃"></a>人生規劃</h2><p>在今年的3月初做了轉換跑道的決定，從原先的接案公司轉到了大架構及多人協作的大公司，真是開了眼界，前端組的成員們各個都有其優勢，組長的規劃力及分析專案的技巧，同事的多年開發經歷、技術上的差距，讓我覺得這個決定並沒有做錯，觀察自己與他們的差異性，並持續精進自己，讓我感到非常快樂。與其他組的協作方式也是跟小公司有所差異，架構的完整度則有雲泥之別，終於可以放心的下班了XD</p>
<p>短期的目標仍未有出現變化，仍會繼續加深自己的知識範圍及深度，往資深工程師方向前行，中期則會希望能前往其他國家或是與遠距辦公的機會，培養除了程式之外的第二專長(廚藝?)，花更少的時間賺取更多的效益，長期規劃希望能在垂垂老矣前，能夠完成自己的夢想清單XD。<br>人際交流上,維持與老朋友的聯繫，並時時互通有無，維持關聯性。新朋友則是保持開放的態度交流。<strong>人脈既是錢脈的</strong><br>旅行遊玩則是，以不減少投資規劃的程度，去進行遊樂及休息。今年開始的健身項目，也會持續進行，但後續的教練課真的太貴，應該不會繼續投資。維持健康的體態並持續減下體脂肪也是明年的重要目標！</p>
]]></content>
      <categories>
        <category>YearReview</category>
      </categories>
      <tags>
        <tag>review</tag>
        <tag>life</tag>
      </tags>
  </entry>
</search>
